<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay hungry ,Stay foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="HybridTheory">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="HybridTheory">
<meta property="og:description" content="Stay hungry ,Stay foolish">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HybridTheory">
<meta name="twitter:description" content="Stay hungry ,Stay foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>HybridTheory</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HybridTheory</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">keep learning</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-blog">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            BLOG
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            TAGS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-todolist">
          <a href="/2019/04/01/demo2/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            TODOLIST
          </a>
        </li>
      
        
        <li class="menu-item menu-item-english">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-music"></i> <br>
            
            ENGLISH
          </a>
        </li>
      
        
        <li class="menu-item menu-item-music">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            MUSIC
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movie">
          <a href="/2019/04/01/movie/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            MOVIE
          </a>
        </li>
      
        
        <li class="menu-item menu-item-news">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            NEWS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-weekly">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            WEEKLY
          </a>
        </li>
      
        
        <li class="menu-item menu-item-space">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            SPACE
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:44:28+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/单例模式/" class="leancloud_visitors" data-flag-title="单例模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88933605" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88933605</a></p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
<p>介绍<br>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例：</p>
<p>1、一个班级只有一个班主任。<br>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br>优点：</p>
<p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>2、避免对资源的多重占用（比如写文件操作）。<br>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：</p>
<p>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<p>实现<br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。</p>
<p>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。</p>
<p>步骤 1<br>创建一个 Singleton 类。</p>
<p>SingleObject.java<br>public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(“Hello World!”); } }</p>
<p>步骤 2<br>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java<br>public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }</p>
<p>步骤 3<br>执行程序，输出结果：</p>
<p>Hello World!<br>单例模式的几种实现方式<br>单例模式的实现有多种方式，如下所示：</p>
<p>1、懒汉式，线程不安全<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：否</p>
<p>实现难度：易</p>
<p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<p>实例<br>public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }</p>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p>
<p>2、懒汉式，线程安全<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>实例<br>public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }</p>
<p>3、饿汉式<br>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<p>实例<br>public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }</p>
<p>4、双检锁/双重校验锁（DCL，即 double-checked locking）<br>JDK 版本：JDK1.5 起</p>
<p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：较复杂</p>
<p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<p>实例<br>public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }</p>
<p>5、登记式/静态内部类<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：一般</p>
<p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p>
<p>实例<br>public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }</p>
<p>6、枚举<br>JDK 版本：JDK1.5 起</p>
<p>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<p>实例<br>public enum Singleton { INSTANCE; public void whateverMethod() { } }</p>
<p>经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/抽象工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/抽象工厂模式/" itemprop="url">抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:42:30+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/抽象工厂模式/" class="leancloud_visitors" data-flag-title="抽象工厂模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88933360" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88933360</a></p>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>主要解决：主要解决接口选择的问题。</p>
<p>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p>如何解决：在一个产品族里面，定义多个产品。</p>
<p>关键代码：在一个工厂里聚合多个同类产品。</p>
<p>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>注意事项：产品族难扩展，产品等级易扩展。</p>
<p>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。</p>
<p>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。</p>
<p>步骤 1<br>为形状创建一个接口。</p>
<p>Shape.java<br>public interface Shape { void draw(); }</p>
<p>步骤 2<br>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<p>Rectangle.java<br>public class Rectangle implements Shape { @Override public void draw() { System.out.println(“Inside Rectangle::draw() method.”); } }</p>
<p>Square.java<br>public class Square implements Shape { @Override public void draw() { System.out.println(“Inside Square::draw() method.”); } }</p>
<p>Circle.java<br>public class Circle implements Shape { @Override public void draw() { System.out.println(“Inside Circle::draw() method.”); } }</p>
<p>步骤 3<br>为颜色创建一个接口。</p>
<p>Color.java<br>public interface Color { void fill(); }</p>
<p>步骤4<br>创建实现接口的实体类。</p>
<p>Red.java<br>public class Red implements Color { @Override public void fill() { System.out.println(“Inside Red::fill() method.”); } }</p>
<p>Green.java<br>public class Green implements Color { @Override public void fill() { System.out.println(“Inside Green::fill() method.”); } }</p>
<p>Blue.java<br>public class Blue implements Color { @Override public void fill() { System.out.println(“Inside Blue::fill() method.”); } }</p>
<p>步骤 5<br>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<p>AbstractFactory.java<br>public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; }</p>
<p>步骤 6<br>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java<br>public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(“CIRCLE”)){ return new Circle(); } else if(shapeType.equalsIgnoreCase(“RECTANGLE”)){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(“SQUARE”)){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } }</p>
<p>ColorFactory.java<br>public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(“RED”)){ return new Red(); } else if(color.equalsIgnoreCase(“GREEN”)){ return new Green(); } else if(color.equalsIgnoreCase(“BLUE”)){ return new Blue(); } return null; } }</p>
<p>步骤 7<br>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java<br>public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(“SHAPE”)){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(“COLOR”)){ return new ColorFactory(); } return null; } }</p>
<p>步骤 8<br>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<p>AbstractFactoryPatternDemo.java<br>public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(“SHAPE”); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(“CIRCLE”); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(“RECTANGLE”); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(“SQUARE”); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(“COLOR”); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(“RED”); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(“Green”); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(“BLUE”); //调用 Blue 的 fill 方法 color3.fill(); } }</p>
<p>步骤 9<br>执行程序，输出结果：</p>
<p>Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.<br>Inside Red::fill() method.<br>Inside Green::fill() method.<br>Inside Blue::fill() method.<br> 工厂模式</p>
<p>单例模式 </p>
<p>1 篇笔记 写笔记</p>
<p>   涛</p>
<p>  <a href="mailto:307***9849@qq.com" target="_blank" rel="noopener">307***9849@qq.com</a></p>
<p>   参考地址</p>
<p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p>
<p>简单工厂模式<br>简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。</p>
<p>比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p>
<p>工厂模式<br>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p>
<p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p>
<p>后续直接调用鼠标工厂.生产鼠标()即可</p>
<p>抽象工厂模式<br>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p>
<p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p>
<p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p>
<p>创建工厂时，由戴尔工厂创建。</p>
<p>后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。</p>
<p>在抽象工厂模式中，假设我们需要增加一个工厂</p>
<p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p>
<p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p>
<p>在抽象工厂模式中，假设我们需要增加一个产品</p>
<p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p>
<p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/工厂方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/工厂方法模式/" itemprop="url">工厂方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:41:15+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/工厂方法模式/" class="leancloud_visitors" data-flag-title="工厂方法模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88929956" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88929956</a><br>一、问题<br>在前一章《设计模式读书笔记—–简单工厂模式》中通过披萨的实例介绍了简单工厂模式。在披萨实例中，如果我想根据地域的不同生产出不同口味的披萨，如纽约口味披萨，芝加哥口味披萨。如果利用简单工厂模式，我们需要两个不同的工厂，NYPizzaFactory、ChicagoPizzaFactory。在该地域中有很多的披萨店，他们并不想依照总店的制作流程来生成披萨，而是希望采用他们自己的制作流程。这个时候如果还使用简单工厂模式，因为简单工厂模式是将披萨的制作流程完全承包了。那么怎么办？</p>
<p>二、解决方案<br>我们可以这样解决：将披萨的制作方法交给各个披萨店完成，但是他们只能提供制作完成的披萨，披萨的订单处理仍然要交给披萨工厂去做。也就是说，我们将createPizza()方法放回到PizzaStore中，其他的部分还是保持不变。</p>
<p>三、基本定义<br>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式让实例化推迟到子类。</p>
<p>四、模式结构<br>工厂方法模式的UML结构图：</p>
<p>Product：抽象产品。所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类既可以引用这个接口。而不是具体类。<br>ConcreteProduct：具体产品。<br>Creator：抽象工厂。它实现了所有操纵产品的方法，但不实现工厂方法。Creator所有的子类都必须要实现factoryMethod()方法。<br>ConcreteCreator：具体工厂。制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。<br>工厂方法模式是简单工厂模式的延伸。在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新的对象时，我们只需要添加一个具体的产品和它的创建工厂即可，不需要对原工厂进行任何修改，这样很好地符合了“开闭原则”。</p>
<p>五、工厂方法模式实现<br>针对上面的解决方案，得到如下UML结构图：</p>
<p>抽象产品类：Pizza.java</p>
<p> 1 public abstract class Pizza {<br> 2     protected String name;        //名称<br> 3     protected String dough;       //面团<br> 4     protected String sause;       //酱料<br> 5     protected List<string> toppings = new ArrayList<string>();       //佐料<br> 6<br> 7<br> 8     public void prepare() {<br> 9         System.out.println(“Preparing “+name);<br>10         System.out.println(“Tossing dough”);<br>11         System.out.println(“Adding sause”);<br>12         System.out.println(“Adding toppings”);<br>13         for(int i = 0;i &lt; toppings.size();i++){<br>14             System.out.println(“   “+toppings.get(i));<br>15         }<br>16     }<br>17<br>18     public void bake() {<br>19         System.out.println(“Bake for 25 minutes at 350”);<br>20     }<br>21<br>22     public void cut() {<br>23         System.out.println(“Cutting the pizza into diagonal slices”);<br>24     }<br>25<br>26     public void box() {<br>27         System.out.println(“Place pizza in official PizzaStore box”);<br>28     }<br>29<br>30     public String getName(){<br>31         return name;<br>32     }<br>33 }<br>具体产品类：NYStyleCheesePizza.java</string></string></p>
<p> 1 public class NYStyleCheesePizza extends Pizza{<br> 2     public NYStyleCheesePizza(){<br> 3         name = “Ny Style Sauce and Cheese Pizza”;<br> 4         dough = “Thin Crust Dough”;<br> 5         sause = “Marinara Sauce”;<br> 6<br> 7         toppings.add(“Crated Reggiano Cheese”);<br> 8     }<br> 9<br>10 }<br>ChicagoStyleCheesePizza.java</p>
<p> 1 public class ChicagoStyleCheesePizza extends Pizza {<br> 2     public ChicagoStyleCheesePizza(){<br> 3         name = “Chicago Style Deep Dish Cheese Pizza”;<br> 4         dough = “Extra Thick Crust Dough”;<br> 5         sause = “Plum Tomato Sauce”;<br> 6<br> 7         toppings.add(“Shredded Mozzarella Cheese”);<br> 8     }<br> 9<br>10     public void cut(){<br>11         System.out.println(“Cutting the Pizza into square slices”);<br>12     }<br>13 }<br>抽象工厂：披萨总店。PizzaStore.java</p>
<p> 1 public abstract class PizzaStore {<br> 2     public Pizza orderPizza(String type){<br> 3         Pizza pizza;<br> 4         pizza = createPizza(type);<br> 5<br> 6         pizza.prepare();<br> 7         pizza.bake();<br> 8         pizza.cut();<br> 9         pizza.box();<br>10<br>11         return pizza;<br>12     }<br>13<br>14     /<em><br>15      </em> 创建pizza的方法交给子类去实现<br>16      */<br>17     abstract Pizza createPizza(String type);<br>18 }<br>具体工厂。披萨分店。NYPizzaStore.java</p>
<p> 1 public class NYPizzaStore extends PizzaStore{<br> 2<br> 3     @Override<br> 4     Pizza createPizza(String item) {<br> 5         Pizza pizza = null;<br> 6         if(“cheese”.equals(item)){<br> 7             pizza = new NYStyleCheesePizza();<br> 8         }<br> 9         else if(“veggie”.equals(item)){<br>10             pizza = new NYStyleVeggiePizza();<br>11         }<br>12         else if(“clam”.equals(item)){<br>13             pizza = new NYStyleClamPizza();<br>14         }<br>15         else if(“pepperoni”.equals(item)){<br>16             pizza = new NYStylePepperoniPizza();<br>17         }<br>18<br>19         return pizza;<br>20     }<br>ChicagoPizzaStore.java</p>
<p> 1 public class ChicagoPizzaStore extends PizzaStore {<br> 2     Pizza createPizza(String type) {<br> 3         Pizza pizza = null;<br> 4         if(“cheese”.equals(type)){<br> 5             pizza = new ChicagoStyleCheesePizza();<br> 6         }<br> 7         else if(“clam”.equals(type)){<br> 8             pizza = new ChicagoStyleClamPizza();<br> 9         }<br>10         else if(“pepperoni”.equals(type)) {<br>11             pizza = new ChicagoStylePepperoniPizza();<br>12         }<br>13         else if(“veggie”.equals(type)){<br>14             pizza = new ChicagoStyleVeggiePizza();<br>15         }<br>16         return pizza;<br>17     }<br>18<br>19 }<br>做了这么多，应该可以吃披萨了吧。Ethan要一份纽约口味的披萨，Joel需要芝加哥口味的披萨。</p>
<p>PizzaTestDrive.java</p>
<p> 1 public class PizzaTestDrive {<br> 2     public static void main(String[] args) {<br> 3         System.out.println(“———Joel 需要的芝加哥的深盘披萨———“);<br> 4         ChicagoPizzaStore chicagoPizzaStore = new ChicagoPizzaStore();       //建立芝加哥的披萨店<br> 5         Pizza joelPizza =chicagoPizzaStore.orderPizza(“cheese”);             //下订单<br> 6         System.out.println(“Joel ordered a “ + joelPizza.getName() + “\n”);<br> 7<br> 8         System.out.println(“———Ethan 需要的纽约风味的披萨———“);<br> 9         NYPizzaStore nyPizzaStore = new NYPizzaStore();<br>10         Pizza ethanPizza = nyPizzaStore.orderPizza(“cheese”);<br>11         System.out.println(“Ethan ordered a “ + ethanPizza.getName() + “\n”);<br>12<br>13     }<br>14 }<br>运行结果。</p>
<p>六、工厂方法模式的优缺点<br>优点<br>1、  在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。<br>2、  在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。<br>缺点<br>1、  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br>七、工厂方法适用场景<br>1、一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。<br>2、一个类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。<br>八、总结<br>1、工厂方法模式完全符合“开闭原则”。<br>2、工厂方法模式使用继承，将对象的创建委托给子类，通过子类实现工厂方法来创建对象。<br>3、工厂方法允许类将实例化延伸到子类进行。<br>4、工厂方法让子类决定要实例化的类时哪一个。在这里我们要明白这并不是工厂来决定生成哪种产品，而是在编写创建者类时，不需要知道实际创建的产品是哪个，选择了使用哪个子类，就已经决定了实际创建的产品时哪个了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/简单工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/简单工厂模式/" itemprop="url">简单工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:40:37+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/简单工厂模式/" class="leancloud_visitors" data-flag-title="简单工厂模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88858312" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88858312</a></p>
<p>在设计原则中有这样一句话“我们应该针对接口编程，而不是正对实现编程”。但是我们还是在一直使用new关键字来创建一个对象，这不就是在针对实现编程么？</p>
<p>针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。入股代码是针对接口而写，那么可以通过多态，它可以与任何新类实现该接口。但是，当代码使用一大堆的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须要改变代码。在这里我们希望能够调用一个简单的方法，我传递一个参数过去，就可以返回给我一个相应的具体对象，这个时候我们就可以使用简单工厂模式。</p>
<p>一、基本定义<br>简单工厂模式又称之为静态工厂方法，属于创建型模式。在简单工厂模式中，可以根据传递的参数不同，返回不同类的实例。简单工厂模式定义了一个类，这个类专门用于创建其他类的实例，这些被创建的类都有一个共同的父类。</p>
<p>二、模式结构<br>模式结构图如下：</p>
<p>模式分析：</p>
<p>Factory：工厂角色。专门用于创建实例类的工厂，提供一个方法，该方法根据传递的参数不同返回不同类的具体实例。<br>Product：抽象产品角色。为所有产品的父类。<br>ConcreteProduct：具体的产品角色。<br>简单工厂模式将对象的创建和对象本身业务处理分离了，可以降低系统的耦合度，使得两者修改起来都相对容易些。当以后实现改变时，只需要修改工厂类即可。</p>
<p>三、简单工厂模式实现<br>模式场景：在一个披萨店中，要根据不同客户的口味，生产不同的披萨，如素食披萨、希腊披萨等披萨。</p>
<p>该例的UML结构图如下:</p>
<p>代码实现</p>
<p>Pizza制造工厂：SimplyPizzaFactory.java</p>
<p> 1 /*<em><br> 2  </em> 专门用于创建披萨的工厂类<br> 3  */<br> 4 public class SimplePizzaFactory {<br> 5     public Pizza createPizza(String type){<br> 6         Pizza pizza = null;<br> 7<br> 8         if(type.equals(“cheese”)){<br> 9             pizza = new CheesePizza();<br>10         }<br>11         else if(type.equals(“clam”)){<br>12             pizza = new ClamPizza();<br>13         }<br>14         else if(type.equals(“pepperoni”)){<br>15             pizza = new PepperoniPizza();<br>16         }<br>17         else if(type.equals(“veggie”)){<br>18             pizza = new VeggiePizze();<br>19         }<br>20<br>21         return pizza;<br>22     }<br>23 }<br>抽象披萨：Pizza.java</p>
<p> 1 /*<em><br> 2  </em> 抽象pizza类<br> 3  */<br> 4 public abstract class Pizza {<br> 5     public abstract void prepare();<br> 6<br> 7     public abstract void bake();<br> 8<br> 9     public abstract void cut();<br>10<br>11     public abstract void box();<br>12 }<br>具体披萨：CheesePizza.java</p>
<p> 1 public class CheesePizza extends Pizza{<br> 2<br> 3     @Override<br> 4     public void bake() {<br> 5         System.out.println(“bake CheesePizza …”);<br> 6     }<br> 7<br> 8     @Override<br> 9     public void box() {<br>10         System.out.println(“box CheesePizza …”);<br>11     }<br>12<br>13     @Override<br>14     public void cut() {<br>15         System.out.println(“cut CheesePizza …”);<br>16     }<br>17<br>18     @Override<br>19     public void prepare() {<br>20         System.out.println(“prepare CheesePizza …”);<br>21     }<br>22<br>23 }<br>PizzaStore.java</p>
<p> 1 public class PizzaStore {<br> 2     SimplePizzaFactory factory;      //SimplePizzaFactory的引用<br> 3     public PizzaStore(SimplePizzaFactory factory){<br> 4         this.factory = factory;<br> 5     }<br> 6<br> 7     public Pizza orderPizza(String type){<br> 8         Pizza pizza;<br> 9         pizza = factory.createPizza(type);       //使用工厂对象的创建方法，而不是直接new。这里不再使用具体实例化<br>10<br>11         pizza.prepare();<br>12         pizza.bake();<br>13         pizza.cut();<br>14         pizza.box();<br>15<br>16         return pizza;<br>17     }<br>18 }<br>四、简单工厂模式的优缺点<br>优点<br>1、简单工厂模式实现了对责任的分割，提供了专门的工厂类用于创建对象。<br>2、客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。<br>3、通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。<br>缺点<br>1、由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。<br>2、使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。<br>3、系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。<br>4、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。<br>五、简单工厂模式的使用场景<br>1、  工厂类负责创建的对象比较少。<br>2、  客户端只知道传入工厂类的参数，对于如何创建对象不关心。<br>六、总结<br>1、  简单工厂模式的要点就在于当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/Spring-Bean-生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/Spring-Bean-生命周期/" itemprop="url">Spring Bean 生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:39:14+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/Spring-Bean-生命周期/" class="leancloud_visitors" data-flag-title="Spring Bean 生命周期">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  912
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88829053" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88829053</a><br>前言<br>Spring Bean 的生命周期在整个 Spring 中占有很重要的位置，掌握这些可以加深对 Spring 的理解。</p>
<p>首先看下生命周期图：</p>
<p>再谈生命周期之前有一点需要先明确：</p>
<p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype （原型模式：多例） 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
<p>注解方式<br>在 bean 初始化时会经历几个阶段，首先可以使用注解 @PostConstruct, @PreDestroy 来在 bean 的创建和销毁阶段进行调用:</p>
<p>@Component<br>public class AnnotationBean {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(AnnotationBean.class);</p>
<pre><code>@PostConstruct
public void start(){
    LOGGER.info(&quot;AnnotationBean start&quot;);
}

@PreDestroy
public void destroy(){
    LOGGER.info(&quot;AnnotationBean destroy&quot;);
}
</code></pre><p>}<br>InitializingBean, DisposableBean 接口<br>还可以实现 InitializingBean,DisposableBean 这两个接口，也是在初始化以及销毁阶段调用：</p>
<p>@Service<br>public class SpringLifeCycleService implements InitializingBean,DisposableBean{<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleService.class);<br>    @Override<br>    public void afterPropertiesSet() throws Exception {<br>        LOGGER.info(“SpringLifeCycleService start”);<br>    }</p>
<pre><code>@Override
public void destroy() throws Exception {
    LOGGER.info(&quot;SpringLifeCycleService destroy&quot;);
}
</code></pre><p>}<br>自定义初始化和销毁方法<br>也可以自定义方法用于在初始化、销毁阶段调用:</p>
<p>@Configuration<br>public class LifeCycleConfig {</p>
<pre><code>@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)
public SpringLifeCycle create(){
    SpringLifeCycle springLifeCycle = new SpringLifeCycle() ;

    return springLifeCycle ;
}
</code></pre><p>}</p>
<p>public class SpringLifeCycle{</p>
<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycle.class);
public void start(){
    LOGGER.info(&quot;SpringLifeCycle start&quot;);
}


public void destroy(){
    LOGGER.info(&quot;SpringLifeCycle destroy&quot;);
}
</code></pre><p>}<br>以上是在 SpringBoot 中可以这样配置，如果是原始的基于 XML 也是可以使用:</p>
<p><bean class="com.crossoverjie.spring.SpringLifeCycle" init-method="start" destroy-method="destroy"><br></bean><br>来达到同样的效果。</p>
<p>实现 <em>Aware 接口
</em>Aware 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 Spring 上下文等。</p>
<p>@Component<br>public class SpringLifeCycleAware implements ApplicationContextAware {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleAware.class);</p>
<pre><code>private ApplicationContext applicationContext ;

@Override
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext ;
    LOGGER.info(&quot;SpringLifeCycleAware start&quot;);
}
</code></pre><p>}<br>这样在 springLifeCycleAware 这个 bean 初始化会就会调用 setApplicationContext 方法，并可以获得 applicationContext 对象。</p>
<p>BeanPostProcessor 增强处理器<br>实现 BeanPostProcessor 接口，Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，可以用于对一些特殊的 bean 进行处理：</p>
<p>@Component<br>public class SpringLifeCycleProcessor implements BeanPostProcessor {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleProcessor.class);</p>
<pre><code>/**
 * 预初始化 初始化之前调用
 * @param bean
 * @param beanName
 * @return
 * @throws BeansException
 */
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (&quot;annotationBean&quot;.equals(beanName)){
        LOGGER.info(&quot;SpringLifeCycleProcessor start beanName={}&quot;,beanName);
    }
    return bean;
}

/**
 * 后初始化  bean 初始化完成调用
 * @param bean
 * @param beanName
 * @return
 * @throws BeansException
 */
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (&quot;annotationBean&quot;.equals(beanName)){
        LOGGER.info(&quot;SpringLifeCycleProcessor end beanName={}&quot;,beanName);
    }
    return bean;
}
</code></pre><p>}<br>执行之后观察结果：</p>
<p>018-03-21 00:40:24.856 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor start beanName=annotationBean<br>2018-03-21 00:40:24.860 [restartedMain] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean start<br>2018-03-21 00:40:24.861 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor end beanName=annotationBean<br>2018-03-21 00:40:24.864 [restartedMain] INFO  c.c.s.aware.SpringLifeCycleAware - SpringLifeCycleAware start<br>2018-03-21 00:40:24.867 [restartedMain] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService start<br>2018-03-21 00:40:24.887 [restartedMain] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle start<br>2018-03-21 00:40:25.062 [restartedMain] INFO  o.s.b.d.a.OptionalLiveReloadServer - LiveReload server is running on port 35729<br>2018-03-21 00:40:25.122 [restartedMain] INFO  o.s.j.e.a.AnnotationMBeanExporter - Registering beans for JMX exposure on startup<br>2018-03-21 00:40:25.140 [restartedMain] INFO  com.crossoverjie.Application - Started Application in 2.309 seconds (JVM running for 3.681)<br>2018-03-21 00:40:25.143 [restartedMain] INFO  com.crossoverjie.Application - start ok!<br>2018-03-21 00:40:25.153 [Thread-8] INFO  o.s.c.a.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3913adad: startup date [Wed Mar 21 00:40:23 CST 2018]; root of context hierarchy<br>2018-03-21 00:40:25.155 [Thread-8] INFO  o.s.j.e.a.AnnotationMBeanExporter - Unregistering JMX-exposed beans on shutdown<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle destroy<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService destroy<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean destroy</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/Java垃圾回收（GC）机制详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/Java垃圾回收（GC）机制详解/" itemprop="url">Java垃圾回收（GC）机制详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:35:48+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/Java垃圾回收（GC）机制详解/" class="leancloud_visitors" data-flag-title="Java垃圾回收（GC）机制详解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88805956" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88805956</a></p>
<p>一、为什么需要垃圾回收</p>
<p>　　如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的。</p>
<p>二、哪些内存需要回收？</p>
<p>哪些内存需要回收是垃圾回收机制第一个要考虑的问题，所谓“要回收的垃圾”无非就是那些不可能再被任何途径使用的对象。那么如何找到这些对象？</p>
<p>1、引用计数法</p>
<p>这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。这种算法使用场景很多，但是，Java中却没有使用这种算法，因为这种算法很难解决对象之间相互引用的情况。看一段代码：</p>
<p>/**</p>
<ul>
<li><p>虚拟机参数：-verbose:gc<br><em>/<br>public class ReferenceCountingGC<br>{<br> private Object instance = null;<br> private static final int _1MB = 1024 </em> 1024;</p>
<p> /*<em> 这个成员属性唯一的作用就是占用一点内存 </em>/<br> private byte[] bigSize = new byte[2 * _1MB];</p>
<p> public static void main(String[] args)<br> {</p>
<pre><code>ReferenceCountingGC objectA = new ReferenceCountingGC();
ReferenceCountingGC objectB = new ReferenceCountingGC();
objectA.instance = objectB;
objectB.instance = objectA;
objectA = null;
objectB = null;

System.gc();
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>看下运行结果：</p>
<p>[GC 4417K-&gt;288K(61440K), 0.0013498 secs]<br>[Full GC 288K-&gt;194K(61440K), 0.0094790 secs]<br>看到，两个对象相互引用着，但是虚拟机还是把这两个对象回收掉了，这也说明虚拟机并不是通过引用计数法来判定对象是否存活的。</p>
<p>2、可达性分析法</p>
<p>这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。</p>
<p>那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：</p>
<p>(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</p>
<p>(2). 方法区中的类静态属性引用的对象。</p>
<p>(3). 方法区中常量引用的对象。</p>
<p>(4). 本地方法栈中JNI(Native方法)引用的对象。</p>
<p>下面给出一个GCRoots的例子，如下图，为GCRoots的引用链。</p>
<p>由图可知，obj8、obj9、obj10都没有到GCRoots对象的引用链，即便obj9和obj10之间有引用链，他们还是会被当成垃圾处理，可以进行回收。</p>
<p>三、四种引用状态</p>
<p>在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。</p>
<p>1、强引用</p>
<p>代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<p>2、软引用</p>
<p>描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。</p>
<p>3、弱引用</p>
<p>描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。</p>
<p>4、虚引用</p>
<p>这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。</p>
<p>对于可达性分析算法而言，未到达的对象并非是“非死不可”的，若要宣判一个对象死亡，至少需要经历两次标记阶段。</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与GCRoots相连的引用链，则该对象被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的finalize方法，若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中，之后会由虚拟机自动建立的、优先级低的Finalizer线程去执行，而虚拟机不必要等待该线程执行结束，即虚拟机只负责建立线程，其他的事情交给此线程去处理。</li>
</ol>
<p>2.对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GCRoots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。如下代码演示了一个对象如何在finalize方法中拯救了自己，然而，它只能拯救自己一次，第二次就被回收了。具体代码如下：</p>
<p>package com.demo;</p>
<p>/*</p>
<ul>
<li>此代码演示了两点：</li>
<li>1.对象可以再被GC时自我拯救</li>
<li>2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</li>
<li><p>*/<br>public class FinalizeEscapeGC {</p>
<p> public String name;<br> public static FinalizeEscapeGC SAVE_HOOK = null;</p>
<p> public FinalizeEscapeGC(String name) {</p>
<pre><code>this.name = name;
</code></pre><p> }</p>
<p> public void isAlive() {</p>
<pre><code>System.out.println(&quot;yes, i am still alive :)&quot;);
</code></pre><p> }</p>
<p> @Override<br> protected void finalize() throws Throwable {</p>
<pre><code>super.finalize();
System.out.println(&quot;finalize method executed!&quot;);
System.out.println(this);
FinalizeEscapeGC.SAVE_HOOK = this;
</code></pre><p> }</p>
<p> @Override<br> public String toString() {</p>
<pre><code>return name;
</code></pre><p> }</p>
<p> public static void main(String[] args) throws InterruptedException {</p>
<pre><code>SAVE_HOOK = new FinalizeEscapeGC(&quot;leesf&quot;);
System.out.println(SAVE_HOOK);
// 对象第一次拯救自己
SAVE_HOOK = null;
System.out.println(SAVE_HOOK);
System.gc();
// 因为finalize方法优先级很低，所以暂停0.5秒以等待它
Thread.sleep(500);
if (SAVE_HOOK != null) {
    SAVE_HOOK.isAlive();
} else {
    System.out.println(&quot;no, i am dead : (&quot;);
}

// 下面这段代码与上面的完全相同,但是这一次自救却失败了
// 一个对象的finalize方法只会被调用一次
SAVE_HOOK = null;
System.gc();
// 因为finalize方法优先级很低，所以暂停0.5秒以等待它
Thread.sleep(500);
if (SAVE_HOOK != null) {
    SAVE_HOOK.isAlive();
} else {
    System.out.println(&quot;no, i am dead : (&quot;);
}
</code></pre><p> }<br>}</p>
</li>
</ul>
<p>运行结果如下：</p>
<p>leesf<br>null<br>finalize method executed!<br>leesf<br>yes, i am still alive :)<br>no, i am dead : (<br>　 由结果可知，该对象拯救了自己一次，第二次没有拯救成功，因为对象的finalize方法最多被虚拟机调用一次。此外，从结果我们可以得知，一个堆对象的this（放在局部变量表中的第一项）引用会永远存在，在方法体内可以将this引用赋值给其他变量，这样堆中对象就可以被其他变量所引用，即不会被回收。</p>
<p>四、方法区的垃圾回收</p>
<p>方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。既然进行垃圾回收，就需要判断哪些是废弃常量，哪些是无用的类。</p>
<p>如何判断废弃常量呢？以字面量回收为例，如果一个字符串“abc”已经进入常量池，但是当前系统没有任何一个String对象引用了叫做“abc”的字面量，那么，如果发生垃圾回收并且有必要时，“abc”就会被系统移出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>如何判断无用的类呢？需要满足以下三个条件</p>
<ol>
<li><p>该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的ClassLoader已经被回收。</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ol>
<p>满足以上三个条件的类可以进行垃圾回收，但是并不是无用就被回收，虚拟机提供了一些参数供我们配置。</p>
<p>五、垃圾收集算法</p>
<p>1、标记-清除（Mark-Sweep）算法</p>
<pre><code>这是最基础的算法，标记-清除算法就如同它的名字样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。这种算法的不足主要体现在效率和空间，从效率的角度讲，标记和清除两个过程的效率都不高；从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。标记-清除算法执行过程如图：
</code></pre><p>2、复制（Copying）算法</p>
<pre><code> 复制算法是为了解决效率问题而出现的，它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。复制算法的执行过程如图：



不过这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。
</code></pre><p>3、标记-整理（Mark-Compact）算法</p>
<pre><code>复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。标记-整理算法的工作过程如图：
</code></pre><p>4、分代收集算法</p>
<p>根据上面的内容，用一张图概括一下堆内存的布局</p>
<pre><code>现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。
</code></pre><p>六、垃圾收集器</p>
<p>垃圾收集器就是上面讲的理论知识的具体实现了。不同虚拟机所提供的垃圾收集器可能会有很大差别，我们使用的是HotSpot，HotSpot这个虚拟机所包含的所有收集器如图：</p>
<p>上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。多说一句，我们必须明确一个观点：没有最好的垃圾收集器，更加没有万能的收集器，只能选择对具体应用最合适的收集器。这也是HotSpot为什么要实现这么多收集器的原因。OK，下面一个一个看一下收集器。</p>
<p>1、Serial收集器</p>
<pre><code>最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。后者意味着，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。Serial收集器运行过程如下图所示：
</code></pre><p>说明：1. 需要STW（Stop The World），停顿时间长。2. 简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。</p>
<p>2、ParNew收集器</p>
<pre><code>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作（看图）。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。ParNew收集器运行过程如下图所示：
</code></pre><p>3、Parallel Scavenge收集器</p>
<pre><code>Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是打到一个可控制的吞吐量。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器。

停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。

虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge收集器也被称为“吞吐量优先收集器”。Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。
</code></pre><p>4、Serial Old收集器</p>
<p>Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p>
<p>5、Parallel Old收集器</p>
<p>Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示：</p>
<p>6、CMS收集器</p>
<p>CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：</p>
<p>(1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。</p>
<p>(2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。</p>
<p>(3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。</p>
<p>(4). 并发清除，回收内存空间，时间很长。</p>
<p>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示:</p>
<p>说明：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。</p>
<p>7、G1收集器</p>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1收集器有以下特点：</p>
<p>(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。</p>
<p>(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。</p>
<p>(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。</p>
<p>(4). 可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<pre><code>在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。
</code></pre><p>8、常用的收集器组合</p>
<p>七、理解GC日志</p>
<pre><code>每种收集器的日志形式都是由它们自身的实现所决定的，换言之，每种收集器的日志格式都可以不一样。不过虚拟机为了方便用户阅读，将各个收集器的日志都维持了一定的共性，来看下面的一段GC日志：
</code></pre><p>[GC [DefNew: 310K-&gt;194K(2368K), 0.0269163 secs] 310K-&gt;194K(7680K), 0.0269513 secs] [Times: user=0.00 sys=0.00, real=0.03 secs]<br>[GC [DefNew: 2242K-&gt;0K(2368K), 0.0018814 secs] 2242K-&gt;2241K(7680K), 0.0019172 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[Full GC (System) [Tenured: 2241K-&gt;193K(5312K), 0.0056517 secs] 4289K-&gt;193K(7680K), [Perm : 2950K-&gt;2950K(21248K)], 0.0057094 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 2432K, used 43K [0x00000000052a0000, 0x0000000005540000, 0x0000000006ea0000)<br>  eden space 2176K,   2% used [0x00000000052a0000, 0x00000000052aaeb8, 0x00000000054c0000)<br>  from space 256K,   0% used [0x00000000054c0000, 0x00000000054c0000, 0x0000000005500000)<br>  to   space 256K,   0% used [0x0000000005500000, 0x0000000005500000, 0x0000000005540000)<br> tenured generation   total 5312K, used 193K [0x0000000006ea0000, 0x00000000073d0000, 0x000000000a6a0000)<br>   the space 5312K,   3% used [0x0000000006ea0000, 0x0000000006ed0730, 0x0000000006ed0800, 0x00000000073d0000)<br> compacting perm gen  total 21248K, used 2982K [0x000000000a6a0000, 0x000000000bb60000, 0x000000000faa0000)<br>   the space 21248K,  14% used [0x000000000a6a0000, 0x000000000a989980, 0x000000000a989a00, 0x000000000bb60000)<br>No shared spaces configured.</p>
<p>1、日志的开头“GC”、“Full GC”表示这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有Full，则说明本次GC停止了其他所有工作线程(Stop-The-World)。看到Full GC的写法是“Full GC(System)”，这说明是调用System.gc()方法所触发的GC。</p>
<p>2、“GC”中接下来的“[DefNew”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p>
<p>3、后面方括号内部的“310K-&gt;194K(2368K)”、“2242K-&gt;0K(2368K)”，指的是该区域已使用的容量-&gt;GC后该内存区域已使用的容量(该内存区总容量)。方括号外面的“310K-&gt;194K(7680K)”、“2242K-&gt;2241K(7680K)”则指的是GC前Java堆已使用的容量-&gt;GC后Java堆已使用的容量(Java堆总容量)。</p>
<p>4、再往后“0.0269163 secs”表示该内存区域GC所占用的时间，单位是秒。最后的“[Times: user=0.00 sys=0.00 real=0.03 secs]”则更具体了，user表示用户态消耗的CPU时间、内核态消耗的CPU时间、操作从开始到结束经过的墙钟时间。后面两个的区别是，墙钟时间包括各种非运算的等待消耗，比如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以如果看到user或sys时间超过real时间是完全正常的。</p>
<h2 id="5、“Heap”后面就列举出堆内存目前各个年代的区域的内存情况。"><a href="#5、“Heap”后面就列举出堆内存目前各个年代的区域的内存情况。" class="headerlink" title="5、“Heap”后面就列举出堆内存目前各个年代的区域的内存情况。"></a>5、“Heap”后面就列举出堆内存目前各个年代的区域的内存情况。</h2><p>作者：HybridTheory_<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/HybridTheory_/article/details/88805956" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88805956</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/线程池原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/线程池原理/" itemprop="url">线程池原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T19:45:27+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/22/线程池原理/" class="leancloud_visitors" data-flag-title="线程池原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言<br>平时接触过多线程开发的童鞋应该都或多或少了解过线程池，之前发布的《阿里巴巴 Java 手册》里也有一条：</p>
<p><img src="/images/pasted-47.png" alt="upload successful"></p>
<p>可见线程池的重要性。</p>
<p>简单来说使用线程池有以下几个目的：</p>
<p>线程是稀缺资源，不能频繁的创建。<br>解耦作用；线程的创建于执行完全分开，方便维护。<br>应当将其放入一个池子中，可以给其他任务进行复用。<br>线程池原理<br>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>
<p>那在 Java 中又是如何实现的呢？</p>
<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>
<p>Executors.newCachedThreadPool()：无限线程池。<br>Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。<br>Executors.newSingleThreadExecutor()：创建单个线程的线程池。<br>常见的四种线程池<br>newFixedThreadPool</p>
<p>public static ExecutorService newFixedThreadPool(int var0) {<br>        return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());<br>    }<br>public static ExecutorService newFixedThreadPool(int var0, ThreadFactory var1) {<br>    return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var1);<br>}</p>
<p>固定大小的线程池，可以指定线程池的大小，该线程池corePoolSize和maximumPoolSize相等，阻塞队列使用的是LinkedBlockingQueue，大小为整数最大值。</p>
<p>该线程池中的线程数量始终不变，当有新任务提交时，线程池中有空闲线程则会立即执行，如果没有，则会暂存到阻塞队列。对于固定大小的线程池，不存在线程数量的变化。同时使用无界的LinkedBlockingQueue来存放执行的任务。当任务提交十分频繁的时候，LinkedBlockingQueue</p>
<p>迅速增大，存在着耗尽系统资源的问题。而且在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源，需要shutdown。</p>
<p>newSingleThreadExecutor</p>
<p>public static ExecutorService newSingleThreadExecutor() {<br>        return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));<br>    }</p>
<pre><code>public static ExecutorService newSingleThreadExecutor(ThreadFactory var0) {
    return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0));
}
</code></pre><p>单个线程线程池，只有一个线程的线程池，阻塞队列使用的是LinkedBlockingQueue,若有多余的任务提交到线程池中，则会被暂存到阻塞队列，待空闲时再去执行。按照先入先出的顺序执行任务。</p>
<p>newCachedThreadPool</p>
<p>public static ExecutorService newCachedThreadPool() {<br>        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());<br>    }</p>
<pre><code>public static ExecutorService newCachedThreadPool(ThreadFactory var0) {
    return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), var0);
}
</code></pre><p>缓存线程池，缓存的线程默认存活60秒。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列，    他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。</p>
<p>newScheduledThreadPool</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int var0) {<br>        return new ScheduledThreadPoolExecutor(var0);<br>    }</p>
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int var0, ThreadFactory var1) {
    return new ScheduledThreadPoolExecutor(var0, var1);
}
</code></pre><p>定时线程池，该线程池可用于周期性地去执行任务，通常用于周期性的同步数据。</p>
<p>scheduleAtFixedRate:是以固定的频率去执行任务，周期是指每次执行任务成功执行之间的间隔。</p>
<p>schedultWithFixedDelay:是以固定的延时去执行任务，延时是指上一次执行成功之后和下一次开始执行的之前的时间。</p>
<p>拒绝策略<br>AbortPolicy:丢弃任务并抛出RejectedExecutionException</p>
<p>CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p>
<p>DiscardOldestPolicy：丢弃队列中最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</p>
<p>DiscardPolicy：丢弃任务，不做任何处理。</p>
<p>其实看这三种方式创建的源码就会发现：</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><p>实际上还是利用 ThreadPoolExecutor 类实现的。</p>
<p>所以我们重点来看下 ThreadPoolExecutor 是怎么玩的。</p>
<p>首先是创建线程的 api：</p>
<p>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<runnable> workQueue, RejectedExecutionHandler handler)<br>这几个核心参数的作用：</runnable></p>
<p>corePoolSize 为线程池的基本大小。<br>maximumPoolSize 为线程池最大线程大小。<br>keepAliveTime 和 unit 则是线程空闲后的存活时间。<br>workQueue 用于存放任务的阻塞队列。<br>handler 当队列和最大线程池都满了之后的饱和策略。<br>了解了这几个参数再来看看实际的运用。</p>
<p>通常我们都是使用:</p>
<p>threadPool.execute(new Job());<br>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 execute() 函数了。</p>
<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>
<p><img src="/images/pasted-48.png" alt="upload successful"></p>
<p>RUNNING 自然是运行状态，指可以接受任务执行队列里的任务<br>SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕。<br>STOP 指调用了 shutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。<br>TIDYING 所有任务都执行完毕，在调用 shutdown()/shutdownNow() 中都会尝试更新为这个状态。<br>TERMINATED 终止状态，当执行 terminated() 后会更新为这个状态。<br>用图表示为：</p>
<p><img src="/images/pasted-49.png" alt="upload successful"></p>
<p>然后看看 execute() 方法是如何处理的：</p>
<p><img src="/images/pasted-50.png" alt="upload successful"></p>
<p>获取当前线程池的状态。<br>当前线程数量小于 coreSize 时创建一个新的线程运行。<br>如果当前线程处于运行状态，并且写入阻塞队列成功。<br>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。<br>如果当前线程池为空就新创建一个线程并执行。<br>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。<br>这里借助《聊聊并发》的一张图来描述这个流程：</p>
<p><img src="/images/pasted-51.png" alt="upload successful"></p>
<p><img src="/images/pasted-52.png" alt="upload successful"></p>
<p>如何配置线程<br>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>
<p>有一点是肯定的，线程池肯定是不是越大越好。</p>
<p>通常我们是需要根据这批任务执行的性质来确定的。</p>
<p>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2<br>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。<br>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>
<p>优雅的关闭线程池<br>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>
<p>其实无非就是两个方法 shutdown()/shutdownNow()。</p>
<p>但他们有着重要的区别：</p>
<p>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。<br>shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。<br>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
<p>shutdownNow() 要更简单粗暴，可以根据实际场景选择不同的方法。</p>
<p>我通常是按照以下方式关闭线程池的：</p>
<pre><code>long start = System.currentTimeMillis();
for (int i = 0; i &lt;= 5; i++) {
    pool.execute(new Job());
}

pool.shutdown();

while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
    LOGGER.info(&quot;线程还在执行。。。&quot;);
}
long end = System.currentTimeMillis();
LOGGER.info(&quot;一共处理了【{}】&quot;, (end - start));
</code></pre><p>pool.awaitTermination(1, TimeUnit.SECONDS) 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。</p>
<p>SpringBoot 使用线程池<br>2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。</p>
<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>
<p>@Configuration<br>public class TreadPoolConfig {</p>
<pre><code>/**
 * 消费队列线程
 * @return
 */
@Bean(value = &quot;consumerQueueThreadPool&quot;)
public ExecutorService buildConsumerQueueThreadPool(){
    ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
            .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();

    ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

    return pool ;
}
</code></pre><p>}<br>使用时：</p>
<pre><code>@Resource(name = &quot;consumerQueueThreadPool&quot;)
private ExecutorService consumerQueueThreadPool;


@Override
public void execute() {

    //消费队列
    for (int i = 0; i &lt; 5; i++) {
        consumerQueueThreadPool.execute(new ConsumerQueueThread());
    }

}
</code></pre><p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>
<p>监控线程池<br>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>
<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>
<p>关于 actuator 就不再细说了，感兴趣的可以看看这篇，有详细整理过如何暴露监控端点。</p>
<p>其实 ThreadPool 本身已经提供了不少 api 可以获取线程状态：</p>
<p><img src="/images/pasted-53.png" alt="upload successful"></p>
<p>很多方法看名字就知道其含义，只需要将这些信息暴露到 SpringBoot 的监控端点中，我们就可以在可视化页面查看当前的线程池状态了。</p>
<p>甚至我们可以继承线程池扩展其中的几个函数来自定义监控逻辑：</p>
<p><img src="/images/pasted-54.png" alt="upload successful"></p>
<p><img src="/images/pasted-55.png" alt="upload successful"><br>看这些名称和定义都知道，这是让子类来实现的。</p>
<p>可以在线程执行前、后、终止状态执行自定义逻辑。</p>
<p>线程池隔离<br>线程池看似很美好，但也会带来一些问题。</p>
<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>
<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>
<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>
<p>所以我们需要将线程池进行隔离。</p>
<p>通常的做法是按照业务进行划分：</p>
<p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
<p>hystrix 隔离<br>这样的需求 Hystrix 已经帮我们实现了。</p>
<p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
<p>下面来看看 Hystrix 简单的应用：</p>
<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>
<p>/**</p>
<ul>
<li>Function:订单服务<br>*</li>
<li>@author crossoverJie</li>
<li>Date: 2018/7/28 16:43</li>
<li><p>@since JDK 1.8<br>*/<br>public class CommandOrder extends HystrixCommand<string> {</string></p>
<p> private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);</p>
<p> private String orderName;</p>
<p> public CommandOrder(String orderName) {</p>
</li>
</ul>
<pre><code>    super(Setter.withGroupKey(
            //服务分组
            HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))
            //线程分组
            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))

            //线程池配置
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(10)
                    .withKeepAliveTimeMinutes(5)
                    .withMaxQueueSize(10)
                    .withQueueSizeRejectionThreshold(10000))

            .andCommandPropertiesDefaults(
                    HystrixCommandProperties.Setter()
                            .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
    )
    ;
    this.orderName = orderName;
}


@Override
public String run() throws Exception {

    LOGGER.info(&quot;orderName=[{}]&quot;, orderName);

    TimeUnit.MILLISECONDS.sleep(100);
    return &quot;OrderName=&quot; + orderName;
}
</code></pre><p>}</p>
<p>/**</p>
<ul>
<li>Function:用户服务<br>*</li>
<li>@author crossoverJie</li>
<li>Date: 2018/7/28 16:43</li>
<li><p>@since JDK 1.8<br>*/<br>public class CommandUser extends HystrixCommand<string> {</string></p>
<p> private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);</p>
<p> private String userName;</p>
<p> public CommandUser(String userName) {</p>
</li>
</ul>
<pre><code>    super(Setter.withGroupKey(
            //服务分组
            HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))
            //线程分组
            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))

            //线程池配置
            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                    .withCoreSize(10)
                    .withKeepAliveTimeMinutes(5)
                    .withMaxQueueSize(10)
                    .withQueueSizeRejectionThreshold(10000))

            //线程池隔离
            .andCommandPropertiesDefaults(
                    HystrixCommandProperties.Setter()
                            .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
    )
    ;
    this.userName = userName;
}


@Override
public String run() throws Exception {

    LOGGER.info(&quot;userName=[{}]&quot;, userName);

    TimeUnit.MILLISECONDS.sleep(100);
    return &quot;userName=&quot; + userName;
}
</code></pre><p>}<br>api 特别简洁易懂，具体详情请查看官方文档。</p>
<p>然后模拟运行：</p>
<pre><code>public static void main(String[] args) throws Exception {
    CommandOrder commandPhone = new CommandOrder(&quot;手机&quot;);
    CommandOrder command = new CommandOrder(&quot;电视&quot;);


    //阻塞方式执行
    String execute = commandPhone.execute();
    LOGGER.info(&quot;execute=[{}]&quot;, execute);

    //异步非阻塞方式
    Future&lt;String&gt; queue = command.queue();
    String value = queue.get(200, TimeUnit.MILLISECONDS);
    LOGGER.info(&quot;value=[{}]&quot;, value);


    CommandUser commandUser = new CommandUser(&quot;张三&quot;);
    String name = commandUser.execute();
    LOGGER.info(&quot;name=[{}]&quot;, name);
}
</code></pre><p>运行结果：</p>
<p><img src="/images/pasted-56.png" alt="upload successful"></p>
<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>
<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>
<p>它的实现原理其实容易猜到：</p>
<p>利用一个 Map 来存放不同业务对应的线程池。</p>
<p>通过刚才的构造函数也能证明：</p>
<p><img src="/images/pasted-57.png" alt="upload successful"></p>
<p>还要注意的一点是：</p>
<p>自定义的 Command 并不是一个单例，每次执行需要 new 一个实例，不然会报 This instance can only be executed once. Please instantiate a new instance. 异常。</p>
<p>总结<br>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/红黑树/" itemprop="url"> 红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T19:38:52+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/22/红黑树/" class="leancloud_visitors" data-flag-title=" 红黑树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  980
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、在理解红黑树之前，先看一些二叉查找树</p>
<p>二叉查找树特性：<br>左字数上所有的节点的值都小于或等于他的根节点上的值</p>
<p>右子树上所有节点的值均大于或等于他的根节点的值</p>
<p>左、右子树也跟别为平衡二叉树</p>
<p>举个二叉树的例子：</p>
<p><img src="/images/pasted-31.png" alt="upload successful"><br>可以看到如果要查询10的话，10&gt;9</p>
<p><img src="/images/pasted-32.png" alt="upload successful"><br>因此到他的右子树，右子树根节点为13，10&lt;13</p>
<p><img src="/images/pasted-33.png" alt="upload successful"><br>因此到其左子树，左子树根节点为11&gt;10</p>
<p><img src="/images/pasted-34.png" alt="upload successful"><br>到其左子树，为10，找到相应的节点</p>
<p><img src="/images/pasted-35.png" alt="upload successful"><br> 不过二叉查找树有一些问题，可能会出现不平横的情况，即如下图所示的情况</p>
<p><img src="/images/pasted-36.png" alt="upload successful"><br> 从这种情况可以看出，明显存在左子树和右子树深度相差过多，在使用平衡情况下的二叉查找树是时间复杂度为logn，而出现这种极端情况的话，想要查9的位置就需要每一次都遍历下一个右子树，很有可能时间复杂度变为n(与数组普通查询的时间复杂度相同)</p>
<p> 基于上述情况，引入了平衡二叉树，红黑树即为平衡二叉树的一种</p>
<p> 二、红黑树</p>
<p> 特性：节点是红色或黑色</p>
<p>  根节点一定是黑色</p>
<p>  每个叶节点都是黑色的空节点(NIL节点)</p>
<p>  每个红节点的两个子节点都是黑色的(从每个叶子到跟的所有路径上不能有两个连续的红节点)(即对于层来说除了NIL节点，红黑节点是交替的，第一层是黑节点那么其下一层肯定都是红节点，反之一样)</p>
<p>  从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</p>
<p>  正是由于这些原因使得红黑树是一个平衡二叉树</p>
<p>  红黑树的例子</p>
<p><img src="/images/pasted-37.png" alt="upload successful"><br>  向红黑树中插入节点14(一般默认插入节点是红色的)</p>
<p><img src="/images/pasted-38.png" alt="upload successful"><br>  在原树上插入20</p>
<p><img src="/images/pasted-39.png" alt="upload successful">  </p>
<p>  可以看到，插入以后树已经不是一个平衡的二叉树，而且并不满足红黑树的要求，因为20和21均为红色，这种情况下就需要对红黑树进行变色，21需要变为黑色，22就会变成红色，如果22变成红色，则需要17和25都变成黑色</p>
<p><img src="/images/pasted-40.png" alt="upload successful"><br>  而17变成黑色显然是不成立的，因为如果17变为黑色，那么13就会变为红色，不满足二叉树的规则，因此此处需要进行另一个操作———左旋操作</p>
<p>  左旋：下图就是一个左旋的例子，一般情况下，如果左子树深度过深，那么便需要进行左旋操作以保证左右子树深度差变小</p>
<p><img src="/images/pasted-41.png" alt="upload successful"><br>  对于上图由于右子树中17变为黑色以后需要把13变成红色，因此进行一次左旋，将17放在根节点，这样既可保证13为红色，左旋后结果</p>
<p><img src="/images/pasted-42.png" alt="upload successful"><br>  而后根据红黑树的要求进行颜色的修改</p>
<p><img src="/images/pasted-43.png" alt="upload successful"> 进行左旋后，发现从根节点17，到1左子树的叶子节点经过了两个黑节点，而到6的左叶子节点或者右叶子节点要经历3个黑节点，很显然也不满足红黑树，因此还需要进行下一步操作，需要进行右旋操作</p>
<p>   右旋：与左旋正好相反</p>
<p><img src="/images/pasted-44.png" alt="upload successful"> 由于是从13节点出现的不平衡，因此对13节点进行右旋，得到结果</p>
<p><img src="/images/pasted-45.png" alt="upload successful"><br>而后再对其节点进行变色，得到结果</p>
<p><img src="/images/pasted-46.png" alt="upload successful"><br>   这便是红黑树的一个变换，它主要用途有很多，例如java中的TreeMap以及JDK1.8以后的HashMap在当个节点中链表长度大于8时都会用到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/HashMap、ConcurrentHashMap-原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/HashMap、ConcurrentHashMap-原理分析/" itemprop="url">HashMap、ConcurrentHashMap 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T19:31:31+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/22/HashMap、ConcurrentHashMap-原理分析/" class="leancloud_visitors" data-flag-title="HashMap、ConcurrentHashMap 原理分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map 这样的 Key Value 在软件开发中是非常经典的结构，常用于在内存中存放数据。</p>
<p>本篇主要想讨论 ConcurrentHashMap 这样一个并发容器，在正式开始之前我觉得有必要谈谈 HashMap，没有它就不会有后面的 ConcurrentHashMap。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>众所周知 HashMap 底层是基于 数组 + 链表 组成的，不过在 jdk1.7 和 1.8 中具体实现稍有不同。</p>
<h2 id="Base-1-7"><a href="#Base-1-7" class="headerlink" title="Base 1.7"></a>Base 1.7</h2><p>1.7 中的数据结构图：</p>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<p>先来看看 1.7 中的实现。</p>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<p>这是 HashMap 中比较核心的几个成员变量；看看分别是什么意思？</p>
<p>初始化桶大小，因为底层是数组，所以这是数组默认的大小。<br>桶最大值。<br>默认的负载因子（0.75）<br>table 真正存放数据的数组。<br>Map 存放数量的大小。<br>桶大小，可在初始化时显式指定。<br>负载因子，可在初始化时显式指定。<br>重点解释下负载因子：</p>
<p>由于给定的 HashMap 的容量大小是固定的，比如默认初始化：</p>
<pre><code>public HashMap() {

this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);

}

public HashMap(int initialCapacity, float loadFactor) {

if (initialCapacity &lt; 0)

throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +

initialCapacity);

if (initialCapacity &gt; MAXIMUM_CAPACITY)

initialCapacity = MAXIMUM_CAPACITY;

if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))

throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +

loadFactor);

this.loadFactor = loadFactor;

threshold = initialCapacity;

init();

}
</code></pre><p>因此通常建议能提前预估 HashMap 的大小最好，尽量的减少扩容带来的性能损耗。给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<p>根据代码可以看到其实真正存放数据的是</p>
<pre><code>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;
</code></pre><p>这个数组，那么它又是如何定义的呢？</p>
<p><img src="/images/pasted-18.png" alt="upload successful"></p>
<p>Entry 是 HashMap 中的一个内部类，从他的成员变量很容易看出：</p>
<ol>
<li>key 就是写入时的键。</li>
<li>value 自然就是值。</li>
<li>开始的时候就提到 HashMap 是由数组和链表组成，所以这个 next 就是用于实现链表结构。</li>
<li>hash 存放的是当前 key 的 hashcode。<br>知晓了基本结构，那来看看其中重要的写入、获取函数：</li>
</ol>
<p>put 方法</p>
<pre><code>public V put(K key, V value) {

if (table == EMPTY_TABLE) {

inflateTable(threshold);

}

if (key == null)

return putForNullKey(value);

int hash = hash(key);

int i = indexFor(hash, table.length);

for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {

Object k;

if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {

V oldValue = e.value;

e.value = value;

e.recordAccess(this);

return oldValue;

}

}

modCount++;

addEntry(hash, key, value, i);

return null;

}
void addEntry(int hash, K key, V value, int bucketIndex) {

if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {

resize(2 * table.length);

hash = (null != key) ? hash(key) : 0;

bucketIndex = indexFor(hash, table.length);

}

createEntry(hash, key, value, bucketIndex);

}

void createEntry(int hash, K key, V value, int bucketIndex) {

Entry&lt;K,V&gt; e = table[bucketIndex];

table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);

size++;

}
</code></pre><p>判断当前数组是否需要初始化。<br>如果 key 为空，则 put 一个空值进去。<br>根据 key 计算出 hashcode。<br>根据计算出的 hashcode 定位出所在桶。<br>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。<br>如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。<br>当调用 addEntry 写入 Entry 时需要判断是否需要扩容。</p>
<p>如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。</p>
<p>而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。</p>
<p>get 方法</p>
<p>再来看看 get 函数：</p>
<pre><code>public V get(Object key) {

if (key == null)

return getForNullKey();

Entry&lt;K,V&gt; entry = getEntry(key);

return null == entry ? null : entry.getValue();

}

final Entry&lt;K,V&gt; getEntry(Object key) {

if (size == 0) {

return null;

}

int hash = (key == null) ? 0 : hash(key);

for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];

e != null;

e = e.next) {

Object k;

if (e.hash == hash &amp;&amp;

((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))

return e;

}

return null;

}
</code></pre><p>Base 1.8首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。</p>
<p>判断该位置是否为链表。<br>不是链表就根据 key、key 的 hashcode 是否相等来返回值。<br>为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。<br>啥都没取到就直接返回 null 。<br>不知道 1.7 的实现大家看出需要优化的点没有？</p>
<p>其实一个很明显的地方就是：</p>
<p>当 Hash 冲突严重时，在桶上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N)。</p>
<p>因此 1.8 中重点优化了这个查询效率。</p>
<p>1.8 HashMap 结构图：</p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<p>先来看看几个核心的成员变量：</p>
<pre><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

/**
* The maximum capacity, used if a higher value is implicitly specified
* by either of the constructors with arguments.
* MUST be a power of two &lt;= 1&lt;&lt;30.
*/

static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

/**
* The load factor used when none specified in constructor.
*/

static final float DEFAULT_LOAD_FACTOR = 0.75f;

static final int TREEIFY_THRESHOLD = 8;

transient Node&lt;K,V&gt;[] table;

/**
* Holds cached entrySet(). Note that AbstractMap fields are used
* for keySet() and values().
*/

transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

/**
* The number of key-value mappings contained in this map.
*/

transient int size;
</code></pre><p>TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。和 1.7 大体上都差不多，还是有几个重要的区别：</p>
<p>HashEntry 修改为 Node。<br>Node 的核心组成其实也是和 1.7 中的 HashEntry 一样，存放的都是 key value hashcode next 等数据。</p>
<p>再来看看核心方法。</p>
<p>put 方法</p>
<p><img src="/images/pasted-20.png" alt="upload successful"></p>
<p>看似要比 1.7 的复杂，我们一步步拆解：</p>
<p>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。<br>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。<br>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。<br>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。<br>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。<br>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。<br>如果在遍历过程中找到 key 相同时直接退出遍历。<br>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。<br>最后判断是否需要进行扩容。<br>get 方法</p>
<pre><code>public V get(Object key) {

Node&lt;K,V&gt; e;

return (e = getNode(hash(key), key)) == null ? null : e.value;

}

final Node&lt;K,V&gt; getNode(int hash, Object key) {

Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;

if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;

(first = tab[(n - 1) &amp; hash]) != null) {

if (first.hash == hash &amp;&amp; // always check first node

((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))

return first;

if ((e = first.next) != null) {

if (first instanceof TreeNode)

return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);

do {

if (e.hash == hash &amp;&amp;

((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))

return e;

} while ((e = e.next) != null);

}

}

return null;

}
</code></pre><p>首先将 key hash 之后取得所定位的桶。get 方法看起来就要简单许多了。</p>
<p>如果桶为空则直接返回 null 。<br>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。<br>如果第一个不匹配，则判断它的下一个是红黑树还是链表。<br>红黑树就按照树的查找方式返回值。<br>不然就按照链表的方式遍历匹配返回值。<br>从这两个核心方法（get/put）可以看出 1.8 中对大链表做了优化，修改为红黑树之后查询效率直接提高到了 O(logn)。</p>
<p>但是 HashMap 原有的问题也都存在，比如在并发场景下使用时容易出现死循环。</p>
<pre><code>final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

for (int i = 0; i &lt; 1000; i++) {

new Thread(new Runnable() {

@Override

public void run() {

map.put(UUID.randomUUID().toString(), &quot;&quot;);

}

}).start();

}
</code></pre><p>看过上文的还记得在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。但是为什么呢？简单分析下。</p>
<p>如下图：</p>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<p>遍历方式<br>还有一个值得注意的是 HashMap 的遍历方式，通常有以下几种：</p>
<pre><code>Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();

while (entryIterator.hasNext()) {

Map.Entry&lt;String, Integer&gt; next = entryIterator.next();

System.out.println(&quot;key=&quot; + next.getKey() + &quot; value=&quot; + next.getValue());

}

Iterator&lt;String&gt; iterator = map.keySet().iterator();

while (iterator.hasNext()){

String key = iterator.next();

System.out.println(&quot;key=&quot; + key + &quot; value=&quot; + map.get(key));

}
</code></pre><p>第一种可以把 key value 同时取出，第二种还得需要通过 key 取一次 value，效率较低。强烈建议使用第一种 EntrySet 进行遍历。</p>
<p>简单总结下 HashMap：无论是 1.7 还是 1.8 其实都能看出 JDK 没有对它做任何的同步操作，所以并发会出问题，甚至 1.7 中出现死循环导致系统不可用（1.8 已经修复死循环问题）。</p>
<p>因此 JDK 推出了专项专用的 ConcurrentHashMap ，该类位于 java.util.concurrent 包下，专门用于解决并发问题。</p>
<p>坚持看到这里的朋友算是已经把 ConcurrentHashMap 的基础已经打牢了，下面正式开始分析。</p>
<p>ConcurrentHashMap<br>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p>
<p>Base 1.7<br>先来看看 1.7 的实现，下面是他的结构图：</p>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<pre><code>/**
* Segment 数组，存放数据时首先需要定位到具体的 Segment 中。
*/

final Segment&lt;K,V&gt;[] segments;

transient Set&lt;K&gt; keySet;

transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {

private static final long serialVersionUID = 2249069246763182397L;

// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶

transient volatile HashEntry&lt;K,V&gt;[] table;

transient int count;

transient int modCount;

transient int threshold;

final float loadFactor;

}
</code></pre><p>看看其中 HashEntry 的组成：Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p>下面也来看看核心的 put get 方法。</p>
<p>put 方法</p>
<pre><code>public V put(K key, V value) {

Segment&lt;K,V&gt; s;

if (value == null)

throw new NullPointerException();

int hash = hash(key);

int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;

if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck

(segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment

s = ensureSegment(j);

return s.put(key, hash, value, false);

}


final V put(K key, int hash, V value, boolean onlyIfAbsent) {

HashEntry&lt;K,V&gt; node = tryLock() ? null :

scanAndLockForPut(key, hash, value);

V oldValue;

try {

HashEntry&lt;K,V&gt;[] tab = table;

int index = (tab.length - 1) &amp; hash;

HashEntry&lt;K,V&gt; first = entryAt(tab, index);

for (HashEntry&lt;K,V&gt; e = first;;) {

if (e != null) {

K k;

if ((k = e.key) == key ||

(e.hash == hash &amp;&amp; key.equals(k))) {

oldValue = e.value;

if (!onlyIfAbsent) {

e.value = value;

++modCount;

}

break;

}

e = e.next;

}

else {

if (node != null)

node.setNext(first);

else

node = new HashEntry&lt;K,V&gt;(hash, key, value, first);

int c = count + 1;

if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)

rehash(node);

else

setEntryAt(tab, index, node);

++modCount;

count = c;

oldValue = null;

break;

}

}

} finally {

unlock();

}

return oldValue;

}
</code></pre><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。</p>
<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<p>尝试自旋获取锁。<br>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。</p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p>再结合图看看 put 的流程。</p>
<p>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。<br>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。<br>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。<br>最后会解除在 1 中所获取当前 Segment 的锁。<br>get 方法</p>
<pre><code>public V get(Object key) {

Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead

HashEntry&lt;K,V&gt;[] tab;

int h = hash(key);

long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;

if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;

(tab = s.table) != null) {

for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile

(tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);

e != null; e = e.next) {

K k;

if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))

return e.value;

}

}

return null;

}
</code></pre><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。get 逻辑比较简单：</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。</p>
<p>Base 1.8<br>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。</p>
<p>那就是查询遍历链表效率太低。</p>
<p>因此 1.8 做了一些数据结构上的调整。</p>
<p>首先来看下底层的组成结构：</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>看起来是不是和 1.8 HashMap 结构类似？</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p>
<p>其中的 val next 都用了 volatile 修饰，保证了可见性。</p>
<p>put 方法</p>
<p>重点来看看 put 函数：</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p>根据 key 计算出 hashcode 。<br>判断是否需要进行初始化。<br>f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。<br>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。<br>如果都不满足，则利用 synchronized 锁写入数据。<br>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。<br>get 方法</p>
<p><img src="/images/pasted-30.png" alt="upload successful"></p>
<p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。<br>如果是红黑树那就按照树的方式获取值。<br>就不满足那就按照链表的方式遍历获取值。<br>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
<p>总结<br>看完了整个 HashMap 和 ConcurrentHashMap 在 1.7 和 1.8 中不同的实现方式相信大家对他们的理解应该会更加到位。</p>
<p>其实这块也是面试的重点内容，通常的套路是：</p>
<p>谈谈你理解的 HashMap，讲讲其中的 get put 过程。<br>1.8 做了什么优化？<br>是线程安全的嘛？<br>不安全会导致哪些问题？<br>如何解决？有没有线程安全的并发容器？<br>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？<br>这一串问题相信大家仔细看完都能怼回面试官。</p>
<p>除了面试会问到之外平时的应用其实也蛮多，像之前谈到的 Guava 中 Cache 的实现就是利用 ConcurrentHashMap 的思想。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/synchronized-关键字原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/synchronized-关键字原理/" itemprop="url">synchronized 关键字原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-22T15:22:18+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/22/synchronized-关键字原理/" class="leancloud_visitors" data-flag-title="synchronized 关键字原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>
<ol>
<li>同步普通方法，锁的是当前对象。</li>
<li>同步静态方法，锁的是当前 Class 对象。</li>
<li>同步块，锁的是 () 中的对象。</li>
</ol>
<p>实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。</p>
<p>具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。</p>
<p>其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>
<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。</p>
<p>流程图如下:</p>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>通过一段代码来演示:</p>
<pre><code>public static void main(String[] args) {
    synchronized (Synchronize.class){
        System.out.println(&quot;Synchronize&quot;);
    }
}
</code></pre><p>使用 javap -c Synchronize 可以查看编译之后的具体信息。<br>    public class com.crossoverjie.synchronize.Synchronize {<br>      public com.crossoverjie.synchronize.Synchronize();<br>        Code:<br>           0: aload_0<br>           1: invokespecial #1                  // Method java/lang/Object.”<init>“:()V<br>           4: return</init></p>
<pre><code>  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize
       2: dup
       3: astore_1
       **4: monitorenter**
       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       8: ldc           #4                  // String Synchronize
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      13: aload_1
      **14: monitorexit**
      15: goto          23
      18: astore_2
      19: aload_1
      20: monitorexit
      21: aload_2
      22: athrow
      23: return
    Exception table:
       from    to  target type
           5    15    18   any
          18    21    18   any
}
</code></pre><p>可以看到在同步块的入口和出口分别有 monitorenter,monitorexit 指令。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>synchronized 很多都称之为重量锁，JDK1.6 中对 synchronized 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。</p>
<p>轻量锁<br>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。</p>
<p>如果更新成功，当前线程就获得了锁。</p>
<p>如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。</p>
<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>
<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。</p>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p>轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)</p>
<p>轻量锁能提升性能的原因是：</p>
<p>认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。</p>
<p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>
<p>当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>
<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。</p>
<p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-userBiasedLocking=false 来关闭偏向锁，并默认进入轻量锁。</p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>适应性自旋</p>
<p>在使用 CAS 时，如果操作失败，CAS 会自旋再次尝试。由于自旋是需要消耗 CPU 资源的，所以如果长期自旋就白白浪费了 CPU。JDK1.6加入了适应性自旋:    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="HybridTheory">
            
              <p class="site-author-name" itemprop="name">HybridTheory</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry ,Stay foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="200" height="86" src="//music.163.com/outchain/player?type=2&id=1329464393&auto=0&height=66"></iframe>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/yourname" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://vk.com/yourname" target="_blank" title="VK Group">
                      
                        <i class="fa fa-fw fa-vk"></i>VK Group</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/yourname" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/yourname" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="skype:yourname?call|chat" target="_blank" title="Skype">
                      
                        <i class="fa fa-fw fa-skype"></i>Skype</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HybridTheory</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">52.2k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Sv4QpdTAhVRkfNsWlhNnvGfo-gzGzoHsz", "4g1FnHoULfh2ekJwdKDWsfhY");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
