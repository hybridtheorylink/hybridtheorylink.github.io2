<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay hungry ,Stay foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="HybridTheory">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="HybridTheory">
<meta property="og:description" content="Stay hungry ,Stay foolish">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HybridTheory">
<meta name="twitter:description" content="Stay hungry ,Stay foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>HybridTheory</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HybridTheory</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">keep learning</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-blog">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            BLOG
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            TAGS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-todolist">
          <a href="/2019/04/01/demo2/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            TODOLIST
          </a>
        </li>
      
        
        <li class="menu-item menu-item-english">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-music"></i> <br>
            
            ENGLISH
          </a>
        </li>
      
        
        <li class="menu-item menu-item-music">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            MUSIC
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movie">
          <a href="/2019/04/01/movie/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            MOVIE
          </a>
        </li>
      
        
        <li class="menu-item menu-item-news">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            NEWS
          </a>
        </li>
      
        
        <li class="menu-item menu-item-weekly">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            WEEKLY
          </a>
        </li>
      
        
        <li class="menu-item menu-item-space">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            SPACE
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/Java-11-新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/Java-11-新特性/" itemprop="url">Java 11 新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:48:16+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/Java-11-新特性/" class="leancloud_visitors" data-flag-title="Java 11 新特性">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/89082455" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/89082455</a></p>
<p>今天我们来看一下Java 11到底是什么、他有什么特别的、到底要不要升级到Java 11。</p>
<p>Java 11有什么特别的</p>
<p>在Oracle官网中，进入下载页面，第一个可供下载的JDK版本已经提换成了Java SE 11 (LTS)，这里的LTS表示Long-Term-Support。</p>
<p>本次发布的Java 11和2017年9月份发布的Java 9以及 2018年3月份发布的Java 10相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，Oracle表示会对Java 11提供大力支持，这一支持将会持续至2026年9月。这是据 Java 8 以后支持的首个长期版本。</p>
<p>为什么说是长期版本，看下面的官方发布的支持路线图表。</p>
<p>上图是一张Oracle 公布的对于各个版本的JDK的Support Roadmap。途中列举了Java 6 - Java 12的正式发布时间以及支持计划。</p>
<p>从中可以看出，在Java 11之前，Java 9和Java 10是不提供长期支持的，而上一个提供长期支持的版本是Java 8，其将会支持到2025年3月。</p>
<p>长期支持，表示Oracle会对其做长期的补丁、安全等扩展支持等。</p>
<p>下一个提供长期支持的版本将会是Java 17，其将于2021年发布。</p>
<p>现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。</p>
<p>现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。</p>
<p>那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？</p>
<p>新特性</p>
<p>1、本地变量类型推断</p>
<p>什么是局部变量类型推断？</p>
<p>var javastack = “javastack”;<br>System.out.println(javastack);<br>大家看出来了，局部变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 String 。</p>
<p>var javastack = “javastack”;<br>就等于：</p>
<p>String javastack = “javastack”;<br>2、字符串加强</p>
<p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>
<p>// 判断字符串是否为空白  </p>
<p>“ “.isBlank();                // true  </p>
<p>// 去除首尾空格  </p>
<p>“ Javastack “.strip();          // “Javastack”  </p>
<p>// 去除尾部空格   </p>
<p>“ Javastack “.stripTrailing();  // “ Javastack”  </p>
<p>// 去除首部空格   </p>
<p>“ Javastack “.stripLeading();   // “Javastack “  </p>
<p>// 复制字符串  </p>
<p>“Java”.repeat(3);             // “JavaJavaJava”  </p>
<p>// 行数统计  </p>
<p>“A\nB\nC”.lines().count();    // 3<br>3、集合加强</p>
<p>自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 of 和 copyOf 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>
<p>示例1：</p>
<p>var list = List.of(“Java”, “Python”, “C”);  </p>
<p>var copy = List.copyOf(list);  </p>
<p>System.out.println(list == copy);   // true<br>示例2：</p>
<p>var list = new ArrayList<string>();  </string></p>
<p>var copy = List.copyOf(list);  </p>
<p>System.out.println(list == copy);   // false </p>
<p>示例1和2代码差不多，为什么一个为true,一个为false?</p>
<p>来看下它们的源码：</p>
<p>static <e> List<e> of(E… elements) {  </e></e></p>
<pre><code>switch (elements.length) { // implicit null check of elements  

    case 0:  

        return ImmutableCollections.emptyList();  

    case 1:  

        return new ImmutableCollections.List12&lt;&gt;(elements[0]);  

    case 2:  

        return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);  

    default:  

        return new ImmutableCollections.ListN&lt;&gt;(elements);  

}  
</code></pre><p>}  </p>
<p>static <e> List<e> copyOf(Collection&lt;? extends E&gt; coll) {  </e></e></p>
<pre><code>return ImmutableCollections.listCopy(coll);  
</code></pre><p>}  </p>
<p>static <e> List<e> listCopy(Collection&lt;? extends E&gt; coll) {  </e></e></p>
<pre><code>if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) {  

    return (List&lt;E&gt;)coll;  

} else {  

    return (List&lt;E&gt;)List.of(coll.toArray());  

}  
</code></pre><p>}<br>可以看出 copyOf 方法会先判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p>
<p>示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false.</p>
<p>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。</p>
<p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>
<p>4、Stream 加强</p>
<p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>
<p>增加单个参数构造方法，可为null<br>Stream.ofNullable(null).count(); // 0<br>增加 takeWhile 和 dropWhile 方法<br>Stream.of(1, 2, 3, 2, 1)  </p>
<pre><code>.takeWhile(n -&gt; n &lt; 3)  

.collect(Collectors.toList());  // [1, 2] 
</code></pre><p>从开始计算，当 n &lt; 3 时就截止。</p>
<p>Stream.of(1, 2, 3, 2, 1)  </p>
<pre><code>.dropWhile(n -&gt; n &lt; 3)  

.collect(Collectors.toList());  // [3, 2, 1] 
</code></pre><p>这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</p>
<p>3）iterate重载</p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>
<p>如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。</p>
<p>5、Optional 加强</p>
<p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<p>Optional.of(“javastack”).orElseThrow();     // javastack  </p>
<p>Optional.of(“javastack”).stream().count();  // 1  </p>
<p>Optional.ofNullable(null)  </p>
<pre><code>.or(() -&gt; Optional.of(&quot;javastack&quot;))  

.get();   // javastack 
</code></pre><p>6、InputStream 加强</p>
<p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p>
<p>var classLoader = ClassLoader.getSystemClassLoader();  </p>
<p>var inputStream = classLoader.getResourceAsStream(“javastack.txt”);  </p>
<p>var javastack = File.createTempFile(“javastack2”, “txt”);  </p>
<p>try (var outputStream = new FileOutputStream(javastack)) {  </p>
<pre><code>inputStream.transferTo(outputStream);  
</code></pre><p>}<br>7、HTTP Client API</p>
<p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p>
<p>来看一下 HTTP Client 的用法：</p>
<p>var request = HttpRequest.newBuilder()  </p>
<pre><code>.uri(URI.create(&quot;https://javastack.cn&quot;))  

.GET()  

.build();  
</code></pre><p>var client = HttpClient.newHttpClient();  </p>
<p>// 同步  </p>
<p>HttpResponse<string> response = client.send(request, HttpResponse.BodyHandlers.ofString());  </string></p>
<p>System.out.println(response.body());  </p>
<p>// 异步  </p>
<p>client.sendAsync(request, HttpResponse.BodyHandlers.ofString())  </p>
<pre><code>.thenApply(HttpResponse::body)  

.thenAccept(System.out::println); 
</code></pre><p>上面的 .GET() 可以省略，默认请求方式为 Get！</p>
<p>更多使用示例可以看这个 API，后续有机会再做演示。</p>
<p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p>
<p>8、化繁为简，一个命令编译运行源代码</p>
<p>看下面的代码。</p>
<p>// 编译<br>javac Javastack.java  </p>
<p>// 运行<br>java Javastack<br>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示。</p>
<p>java Javastack.java<br>更多新特性</p>
<p>新发布的Java 11在新特性方面，提供了17个JEP(JDK Enhancement Proposal 特性增强提议)</p>
<p>上图是Oracle公布的Java 11包含的所有新特性，其中几个重点的新特性为：</p>
<p>ZGC：可扩展的低延迟垃圾收集器</p>
<p>ZGC是一款号称可以保证每次GC的停顿时间不超过10MS的垃圾回收器，并且和当前的默认垃圾回收起G1相比，吞吐量下降不超过15%。</p>
<p>Epsilon：什么事也不做的垃圾回收器</p>
<p>Java 11还加入了一个比较特殊的垃圾回收器——Epsilon，该垃圾收集器被称为“no-op”收集器，将处理内存分配而不实施任何实际的内存回收机制。 也就是说，这是一款不做垃圾回收的垃圾回收器。这个垃圾回收器看起来并没什么用，主要可以用来进行性能测试、内存压力测试等，Epsilon GC可以作为度量其他垃圾回收器性能的对照组。大神Martijn说，Epsilon GC至少能够帮助理解GC的接口，有助于成就一个更加模块化的JVM。</p>
<p>增强var用法</p>
<p>Java 10中增加了本地变量类型推断的特性，可以使用var来定义局部变量。尽管这一特性被很多人诟病，但是并不影响Java继续增强他的用法，在Java 11中，var可以用来作为Lambda表达式的局部变量声明。</p>
<p>移除Java EE和CORBA模块</p>
<p>早在发布Java SE 9的时候，Java就表示过，会在未来版本中将Java EE和CORBA模块移除，而这样举动终于在Java 11中实施。终于去除了Java EE和CORBA模块。</p>
<p>HTTP客户端进一步升级</p>
<p>JDK 9 中就已对 HTTP Client API 进行标准化，然后通过JEP 110，在 JDK 10 中进行了更新。在本次的Java 11的更新列表中，由以JEP 321进行进一步升级。该API通过CompleteableFutures提供非阻塞请求和响应语义，可以联合使用以触发相应的动作。 JDK 11完全重写了该功能。现在，在用户层请求发布者和响应发布者与底层套接字之间追踪数据流更容易了，这降低了复杂性，并最大程度上提高了HTTP / 1和HTTP / 2之间的重用的可能性。</p>
<p>到底要不要升级</p>
<p>2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次。</p>
<p>2017年9月，Java 9发布。<br>2018年3月，Java 10发布。<br>2018年9月，Java 11发布。<br>大部分人使用的JDK版本还是Java 8及以下版本，甚至某些公司的生产环境使用的还是JDK 1.6。</p>
<p>那么，对于公司和开发者来说，到底要不要在生产及开发环境中升级和学习Java 11呢?</p>
<p>对于企业来说</p>
<p>对于企业来说，生产环境中的JDK版本升级到Java 11还是有必要的。主要有两个原因：</p>
<p>1、Oracle会对Java 11提供长期支持，企业可以放心使用这一版本。并且下一个长期支持的版本会在三年后发布，时间比较久远。</p>
<p>2、Java 11确实提供了一些比较不错的特性，尤其重要的是提供了ZGC，这是一款具有划时代意义的垃圾回收器。优点不再赘述。有了ZGC，JVM的性能瓶颈可以被突破。</p>
<p>对于开发者来说</p>
<p>在编码方面，Java 11并没有像Java 8那样变化巨大，毕竟Java 8提供了函数式编程的能力，这也是很多开发者学习Java 8的一个重要原因。</p>
<p>但是，Java 11也并不是完全没有提升，至少在新版本中，Java开发者终于可以摆脱老旧的HttpURLConnection了。新的HTTP API提供了对HTTOP/2等业界前沿标准的支持，提供了精简而又友好的API接口。</p>
<p>所以，综上所述，无论是对于企业还是开发者来说，升级Java 11都是有必要的，至少比Java 9和Java 10的必要性要大很多。至于这个必要性到底有多大呢，作者给一个简单的说明：</p>
<p>如果你现在时候用的JDK/Java版本低于Java 8，先升级到Java 8。<br>如果你现在时候用的JDK/Java版本高于Java 7，那么可以考虑升级到Java 11了。 当然，你可以直接从Java 6跳跃到Java 11。<br>最后</p>
<p>现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/Java-12-新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/Java-12-新特性/" itemprop="url">Java 12 新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:47:36+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/Java-12-新特性/" class="leancloud_visitors" data-flag-title="Java 12 新特性">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/89081472" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/89081472</a></p>
<p>在 Java 9 之前，当一个版本被宣布为首选版本，存在一个“培育”（bedded-in）新 GA 版本的重叠期。在此期间，上一个版本将会继续进行免费更新。为确保新旧版本间的干净切换，即便旧版本已不再是首选版本，通常也会继续维护 12 个月以上。但是随着 Java 版本发布更改为遵循严格的时间表后，事实上宣告了传统的免费支持期将寿终正寝。</p>
<p>Oracle 对 Java 8 的官方支持时间持续到 2020 年 12 月，之后将不再为个人桌面用户提供 Oracle JDK 8 的修复更新；在 2019 年 1 月之后，不再提供免费的商业版本更新，届时想要继续获得 Oracle 的商业支持和维护，需付费订阅。</p>
<p>Java 是很多程序员的饭碗，Java 生态圈下的程序员们似乎对于 Oracle 也有诸多不满，当 Java 也像 Android 系统走上版本号的稳定道路后，新版本的发布意义还有那么大吗？Java 12 已经发布了，但使用版本最多的还是 Java 8，你会选择升级吗？</p>
<p>JDK12 如期而至，不知不觉 Java 半年为周期的发布模式（Half-year-cadence）已经成功运行了一年多，OpenJDK 社区和 Oracle 充分展示了其坚决的执行力。今天当然要尝鲜 JDK12 的新特性，与此同时，笔者也会从不同角度，来分析新发布模式是否达到了其初衷。</p>
<p>下载地址：</p>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>
<p>JDK 12 新特性一览：</p>
<p>189：Shenandoah: A Low-Pause-Time Garbage Collector (Experimental)</p>
<p>230：Microbenchmark Suite</p>
<p>325：Switch Expressions (Preview)</p>
<p>334：JVM Constants API</p>
<p>340：One AArch64 Port, Not Two</p>
<p>341：Default CDS Archives</p>
<p>344：Abortable Mixed Collections for G1</p>
<p>346：Promptly Return Unused Committed Memory from G1</p>
<p>首先值得关注的是 Switch Expressions，这是一个为开发者准备的特性，我们可以利用具体代码快速了解一下，下面是传统 statement 形式的 switch 语法：</p>
<p>switch(day){<br>     case MONDAY:<br>     case FRIDAY:<br>     case SUNDAY:<br>            System.out.println(6);<br>            break;<br>     case TUESDAY:<br>            System.out.println(7);<br>            break;<br>     case THURSDAY:<br>     case SATURDAY:<br>            System.out.println(8);<br>            break;<br>     case WEDNESDAY:<br>            System.out.println(9);<br>            break;<br>}<br>如果有编码经验，你一定知道，switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。如果换成 switch 表达式，Pattern Matching 机制能够自然地保证只有单一路径会被执行，请看下面的代码示例：</p>
<p>switch (day) {<br>        case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);<br>        case TUESDAY -&gt; System.out.println(7);<br>        case THURSDAY, SATURDAY -&gt; System.out.println(8);<br>        case WEDNESDAY -&gt; System.out.println(9);<br>}<br>更进一步，下面的表达式，为我们提供了优雅地表达特定场合计算逻辑的方式</p>
<p>int numLetters = switch (day) {<br>       case MONDAY, FRIDAY, SUNDAY -&gt; 6;<br>       case TUESDAY -&gt; 7;<br>       case THURSDAY, SATURDAY -&gt; 8;<br>       case WEDNESDAY -&gt; 9;<br>};<br>Switch Expressions 或者说起相关的 Pattern Matching 特性，为我们提供了勾勒出了 Java 语法进化的一个趋势，将开发者从复杂繁琐的低层次抽象中逐渐解放出来，以更高层次更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。</p>
<p>第二，则是很有现实意义度 Shenandoah GC。它是 Redhat 主导开发的 Pauseless GC 实现，从大概 2013 年开始研发，终于取得了重要的阶段性成果，与其他 Pauseless GC 类似，Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。</p>
<p>也许了解 Shenandoah GC 的人比较少，业界声音比较响亮的是 Oracle 在 JDK11 中开源出来的 ZGC，或者商业版本的 Azul C4（Continuously Concurrent Compacting Collector）。但是，笔者认为，至少目前，其实际意义大于后两者，因为：</p>
<p>使用 ZGC 的最低门槛是升级到 JDK11，对很多团队来说，这种版本的跳跃并不是非常低成本的事情，更何况是尚不清楚 ZGC 在自身业务场景中的实际表现如何。</p>
<p>而 C4，毕竟是土豪们的选择，现实情况是，有多少公司连个几十块钱的 License 都不舍得…</p>
<p>而 Shenandoah GC 可是有稳定的 JDK8u 版本发布的哦，据我所知已经有个别公司在 HBase 等高实时性产品中实践许久。</p>
<p>从原理的角度，我们可以参考该项目官方的示意图，其内存结构与 G1 非常相似，都是将内存划分为类似棋盘的 region。整体流程与 G1 也是比较相似的，最大的区别在于实现了并发的 Evacuation 环节，引入的 Brooks Forwarding Pointer 技术使得 GC 在移动对象时，对象引用仍然可以访问。</p>
<p>下面是 jbb15 benchmark 中，Shenandoah GC 相对于其他主流 GC 的表现，GC 暂停相比于 CMS 等选择有数量级程度的提高，对于 GC 暂停非常敏感的场景，价值还是很明显的，能够在 SLA 层面有显著提高。当然，这种对于低延迟的保证，也是以消耗 CPU 等计算资源为代价的，实际吞吐量表现也不是非常明朗，需要看企业的实际场景需求，并不是一个一劳永逸的解决方案。</p>
<p>其他的一些特性，例如，G1 相关的两个特性是对 G1 在特定场景不足的有效改进，但谈不上是突破性的提高，不再一一列举。</p>
<p>与 JDK11 这种长期支持版本（Long-Term-Support，LTS）相比，JDK12 似乎关注度有限，大家对于 JDK 这种频繁的节奏也有点麻木了，那么</p>
<p>JDK12 这种非 LTS 版本，是否有什么生产环境价值？</p>
<p>Java 新的发布模式是否达到了其快速落地和迭代新特性的目的？</p>
<p>也许不会有太多公司直接选择 JDK12，但个别的生产实践并不遥远。比如，我所在部门在实践场景中发现，利用 JDK 12 的 Abortable Mixed Collections for G1，解决了 HDFS 在特定场景中 G1 Evacuation 时间过长的困扰，虽然最后团队选择将其 backport 到了自己的 JDK11 版本中，但如果没有快速交付的预览版 JDK12，也不会如此快速的得到结论。</p>
<p>而对另一个问题，笔者认为目前看是非常成功的，解开了 Java/JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。你可能注意到了 Switch Expressions 被打上了预览（Preview）的标签，Shenandoah GC 则是实验（Experimental）特性，这些都是以往的发布周期下不大现实的，因为用 2-3 年的最小间隔粒度来实验一个特性，基本是不现实的。</p>
<p>可以预计，JDK8 在未来的一段时间仍将是主流，我们已经注意到 Amazon、Alibaba、Redhat、AdoptOpenJDK 等等厂商或社区，纷纷发布了自己的 JDK8 等产品，开始竞赛长期支持版本 JDK 的主导权，笔者认为这是非常好的迹象，反映了主流厂商对于 Java 的投资力度增大。</p>
<p>是否会带来 Java/JVM 的碎片化呢？多少会发生一些，但从目前的合作模式来看，OpenJDK 仍然是合作的中心，主导这 Java 历史版本维护和未来的演进路线。</p>
<p>一些小鲜肉语言嘲笑 Java，实现类似功能，Java 代码要多写近一倍，程序要笨重一个数量级，有些也许是言过其实，但语法的表达能力和 JVM 的庞大，确实逐渐成为 Java 发展的短板，JDK10～12 发布的不间断成功，让我们看到了 Java/JVM 大踏步前进的曙光！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/桥接模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/桥接模式/" itemprop="url">桥接模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:46:57+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/桥接模式/" class="leancloud_visitors" data-flag-title="桥接模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/89046766" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/89046766</a></p>
<p>桥接模式<br>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<p>介绍<br>意图：将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p>主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p>如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p>关键代码：抽象类依赖实现类。</p>
<p>应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<p>优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
<p>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p>使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<p>实现<br>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。</p>
<p>步骤 1<br>创建桥接实现接口。</p>
<p>DrawAPI.java<br>public interface DrawAPI {<br>   public void drawCircle(int radius, int x, int y);<br>}<br>步骤 2<br>创建实现了 DrawAPI 接口的实体桥接实现类。</p>
<p>RedCircle.java<br>public class RedCircle implements DrawAPI {<br>   @Override<br>   public void drawCircle(int radius, int x, int y) {<br>      System.out.println(“Drawing Circle[ color: red, radius: “</p>
<pre><code>+ radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
</code></pre><p>   }<br>}<br>GreenCircle.java</p>
<p>public class GreenCircle implements DrawAPI {<br>   @Override<br>   public void drawCircle(int radius, int x, int y) {<br>      System.out.println(“Drawing Circle[ color: green, radius: “</p>
<pre><code>+ radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
</code></pre><p>   }<br>}<br>步骤 3<br>使用 DrawAPI 接口创建抽象类 Shape。</p>
<p>Shape.java<br>public abstract class Shape {<br>   protected DrawAPI drawAPI;<br>   protected Shape(DrawAPI drawAPI){<br>      this.drawAPI = drawAPI;<br>   }<br>   public abstract void draw();<br>}<br>步骤 4<br>创建实现了 Shape 接口的实体类。</p>
<p>Circle.java<br>public class Circle extends Shape {<br>   private int x, y, radius;</p>
<p>   public Circle(int x, int y, int radius, DrawAPI drawAPI) {<br>      super(drawAPI);<br>      this.x = x;<br>      this.y = y;<br>      this.radius = radius;<br>   }</p>
<p>   public void draw() {<br>      drawAPI.drawCircle(radius,x,y);<br>   }<br>}<br>步骤 5<br>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p>
<p>BridgePatternDemo.java<br>public class BridgePatternDemo {<br>   public static void main(String[] args) {<br>      Shape redCircle = new Circle(100,100, 10, new RedCircle());<br>      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());</p>
<pre><code>redCircle.draw();
greenCircle.draw();
</code></pre><p>   }<br>}<br>步骤 6<br>执行程序，输出结果：</p>
<p>Drawing Circle[ color: red, radius: 10, x: 100, 100]<br>Drawing Circle[  color: green, radius: 10, x: 100, 100]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/建造者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/建造者模式/" itemprop="url">建造者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:46:14+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/建造者模式/" class="leancloud_visitors" data-flag-title="建造者模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/89032852" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/89032852</a></p>
<p>建造者模式<br>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<p>介绍<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p>主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>何时使用：一些基本部件不会变，而其组合经常变化的时候。</p>
<p>如何解决：将变与不变分离开。</p>
<p>关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p>应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
<p>优点： 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
<p>缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<p>使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
<p>注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<p>实现<br>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。</p>
<p>步骤 1<br>创建一个表示食物条目和食物包装的接口。</p>
<p>Item.java<br>public interface Item {<br>   public String name();<br>   public Packing packing();<br>   public float price();<br>}<br>Packing.java<br>public interface Packing { public String pack(); }<br>步骤 2<br>创建实现 Packing 接口的实体类。</p>
<p>Wrapper.java<br>public class Wrapper implements Packing { @Override public String pack() { return “Wrapper”; } }<br>Bottle.java<br>public class Bottle implements Packing {</p>
<p>   @Override<br>   public String pack() {<br>      return “Bottle”;<br>   }<br>}<br>步骤 3<br>创建实现 Item 接口的抽象类，该类提供了默认的功能。</p>
<p>Burger.java<br>public abstract class Burger implements Item {</p>
<p>   @Override<br>   public Packing packing() {<br>      return new Wrapper();<br>   }</p>
<p>   @Override<br>   public abstract float price();<br>}<br>ColdDrink.java<br>public abstract class ColdDrink implements Item {</p>
<pre><code>@Override
public Packing packing() {
   return new Bottle();
}

@Override
public abstract float price();
</code></pre><p>}<br>步骤 4<br>创建扩展了 Burger 和 ColdDrink 的实体类。</p>
<p>VegBurger.java<br>public class VegBurger extends Burger {</p>
<p>   @Override<br>   public float price() {<br>      return 25.0f;<br>   }</p>
<p>   @Override<br>   public String name() {<br>      return “Veg Burger”;<br>   }<br>}<br>ChickenBurger.java<br>public class ChickenBurger extends Burger {</p>
<p>   @Override<br>   public float price() {<br>      return 50.5f;<br>   }</p>
<p>   @Override<br>   public String name() {<br>      return “Chicken Burger”;<br>   }<br>}<br>Coke.java<br>public class Coke extends ColdDrink {</p>
<p>   @Override<br>   public float price() {<br>      return 30.0f;<br>   }</p>
<p>   @Override<br>   public String name() {<br>      return “Coke”;<br>   }<br>}<br>Pepsi.java<br>public class Pepsi extends ColdDrink {</p>
<p>   @Override<br>   public float price() {<br>      return 35.0f;<br>   }</p>
<p>   @Override<br>   public String name() {<br>      return “Pepsi”;<br>   }<br>}<br>步骤 5<br>创建一个 Meal 类，带有上面定义的 Item 对象。</p>
<p>Meal.java</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class Meal {<br>   private List<item> items = new ArrayList<item>();    </item></item></p>
<p>   public void addItem(Item item){<br>      items.add(item);<br>   }</p>
<p>   public float getCost(){<br>      float cost = 0.0f;<br>      for (Item item : items) {<br>         cost += item.price();<br>      }<br>      return cost;<br>   }</p>
<p>   public void showItems(){<br>      for (Item item : items) {<br>         System.out.print(“Item : “+item.name());<br>         System.out.print(“, Packing : “+item.packing().pack());<br>         System.out.println(“, Price : “+item.price());<br>      }<br>   }<br>}<br>步骤 6<br>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。</p>
<p>MealBuilder.java<br>public class MealBuilder {</p>
<p>   public Meal prepareVegMeal (){<br>      Meal meal = new Meal();<br>      meal.addItem(new VegBurger());<br>      meal.addItem(new Coke());<br>      return meal;<br>   }   </p>
<p>   public Meal prepareNonVegMeal (){<br>      Meal meal = new Meal();<br>      meal.addItem(new ChickenBurger());<br>      meal.addItem(new Pepsi());<br>      return meal;<br>   }<br>}<br>步骤 7<br>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。</p>
<p>BuilderPatternDemo.java<br>public class BuilderPatternDemo {<br>   public static void main(String[] args) {<br>      MealBuilder mealBuilder = new MealBuilder();</p>
<pre><code>Meal vegMeal = mealBuilder.prepareVegMeal();
System.out.println(&quot;Veg Meal&quot;);
vegMeal.showItems();
System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());

Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
System.out.println(&quot;\n\nNon-Veg Meal&quot;);
nonVegMeal.showItems();
System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());
</code></pre><p>   }<br>}<br>步骤 8<br>执行程序，输出结果：</p>
<p>Veg Meal<br>Item : Veg Burger, Packing : Wrapper, Price : 25.0<br>Item : Coke, Packing : Bottle, Price : 30.0<br>Total Cost: 55.0</p>
<p>Non-Veg Meal<br>Item : Chicken Burger, Packing : Wrapper, Price : 50.5<br>Item : Pepsi, Packing : Bottle, Price : 35.0<br>Total Cost: 85.5<br> 单例模式</p>
<p>原型模式 </p>
<p>2 篇笔记 写笔记</p>
<p>建造者模式举例：去肯德基点餐，我们可以认为点餐就属于一个建造订单的过程。我们点餐的顺序是无关的，点什么东西也是没有要求的，可以单点，也可以点套餐，也可以套餐加单点，但是最后一定要点确认来完成订单。</p>
<p>public class OrderBuilder{<br>    private Burger mBurger;<br>    private Suit mSuit;</p>
<pre><code>//单点汉堡,num为数量
public OrderBuilder burger(Burger burger， int num){
    mBurger = burger;
}

//点套餐，实际中套餐也可以点多份
public OrderBuilder suit(Suit suit, int num){
mSuit = suit;
}

//完成订单
public Order build(){
    Order order = new Order();
    order.setBurger(mBurger);
    order.setSuit(mSuit);
    return order;
}
</code></pre><p>}<br>另外适用于快速失败，在 build 时可以做校验，如果不满足必要条件，则可以直接抛出创建异常，在 OkHttp3 中的 Request.Builder 中就是这样用的。</p>
<p>public Request build() {<br>    if (url == null) throw new IllegalStateException(“url == null”);<br>    return new Request(this);<br>}<br>例如订单要求价格至少达到 30 块:</p>
<p>//完成订单<br>public Order build(){<br>    Order order = new Order();<br>    order.setBurger(mBurger);<br>    order.setSuit(mSuit);<br>    if(order.getPrice() &lt; 30){<br>        throw new BuildException(“订单金额未达到30元”);<br>    }<br>    return order;<br>}<br>另外，在构建时如果有必传参数和可选参数，可以为 Builder 类添加构造函数来保证必传参数不会遗漏，例如在构建一个 http 请求时, url 是必传的:</p>
<p>public class RequestBuilder{<br>    private final String mUrl;<br>    private Map&lt;String, String&gt; mHeaders = new HashMap&lt;String, String&gt;();</p>
<pre><code>private RequestBuilder(String url){
    mUrl = url;
}

public static RequestBuilder newBuilder(String url){
    return new RequestBuilder(url);
}

public RequestBuilder addHeader(String key, String value){
    mHeaders.put(key, value);
}

public Request build(){
    Request request = new Request();
    request.setUrl(mUrl);
    request.setHeaders(mHeaders);
    return request;
}
</code></pre><p>}</p>
<p>建造者模式，又称生成器模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p>三个角色：建造者、具体的建造者、监工、使用者（严格来说不算）</p>
<p>注意：定义中“将一个复杂的构建过程与其表示相分离”，表示并不是由建造者负责一切，而是由监工负责控制（定义）一个复杂的构建过程，由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。</p>
<p>建造者角色：</p>
<p>public abstract class Builder {<br>    public abstract void buildPart1();<br>    public abstract void buildPart2();<br>    public abstract void buildPart3();<br>}<br>监工角色：</p>
<p>public class Director {    // 将一个复杂的构建过程与其表示相分离<br>    private Builder builder;    // 针对接口编程，而不是针对实现编程<br>    public Director(Builder builder) {<br>        this.builder = builder;<br>    }<br>    public void setBuilder(Builder builder) {<br>        this.builder = builder;<br>    }</p>
<pre><code>public void construct() {   // 控制（定义）一个复杂的构建过程
    builder.buildPart1();
    for (int i = 0; i &lt; 5; i++) {   // 提示：如果想在运行过程中替换构建算法，可以考虑结合策略模式。
        builder.buildPart2();
    }
    builder.buildPart3();
}
</code></pre><p>}<br>具体的建造者角色：</p>
<p>/**</p>
<ul>
<li>此处实现了建造纯文本文档的具体建造者。</li>
<li>可以考虑再实现一个建造HTML文档、XML文档，或者其它什么文档的具体建造者。</li>
<li><p>这样，就可以使得同样的构建过程可以创建不同的表示<br>*/<br>public class ConcreteBuilder1 extends Builder {<br>private StringBuffer buffer = new StringBuffer();//假设 buffer.toString() 就是最终生成的产品</p>
<p> @Override<br> public void buildPart1() {//实现构建最终实例需要的所有方法</p>
<pre><code>buffer.append(&quot;Builder1 : Part1\n&quot;);
</code></pre><p> }</p>
<p> @Override<br> public void buildPart2() {</p>
<pre><code>buffer.append(&quot;Builder1 : Part2\n&quot;);
</code></pre><p> }</p>
<p> @Override<br> public void buildPart3() {</p>
<pre><code>buffer.append(&quot;Builder1 : Part3\n&quot;);
</code></pre><p> }</p>
<p> public String getResult() {//定义获取最终生成实例的方法</p>
<pre><code>return buffer.toString();
</code></pre><p> }<br>}<br>客户角色：</p>
</li>
</ul>
<p>public class Client {<br>    public void testBuilderPattern() {<br>        ConcreteBuilder1 b1 = new ConcreteBuilder1();//建造者<br>        Director director = new Director(b1);//监工<br>        director.construct();//建造实例(监工负责监督，建造者实际建造)<br>        String result = b1.getResult();//获取最终生成结果<br>        System.out.printf(“the result is :%n%s”, result);<br>    }<br>}</p>
<p> 建造者角色：定义生成实例所需要的所有方法；<br> 具体的建造者角色：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；<br> 监工角色：定义使用建造者角色中的方法来生成实例的方法；<br> 使用者：使用建造者模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/代理模式、动态代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/代理模式、动态代理模式/" itemprop="url">代理模式、动态代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:45:18+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/代理模式、动态代理模式/" class="leancloud_visitors" data-flag-title="代理模式、动态代理模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/89002972" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/89002972</a></p>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>介绍<br>意图：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p>何时使用：想在访问一个类时做一些控制。</p>
<p>如何解决：增加中间层。</p>
<p>关键代码：实现与被代理类组合。</p>
<p>应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p>
<p>优点： 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p>缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p>使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p>注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<p>实现<br>我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。</p>
<p>ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。</p>
<p>步骤 1<br>创建一个接口。</p>
<p>Image.java<br>public interface Image {<br>   void display();<br>}<br>步骤 2<br>创建实现接口的实体类。</p>
<p>RealImage.java<br>public class RealImage implements Image {</p>
<p>   private String fileName;</p>
<p>   public RealImage(String fileName){<br>      this.fileName = fileName;<br>      loadFromDisk(fileName);<br>   }</p>
<p>   @Override<br>   public void display() {<br>      System.out.println(“Displaying “ + fileName);<br>   }</p>
<p>   private void loadFromDisk(String fileName){<br>      System.out.println(“Loading “ + fileName);<br>   }<br>}<br>ProxyImage.java<br>public class ProxyImage implements Image{</p>
<p>   private RealImage realImage;<br>   private String fileName;</p>
<p>   public ProxyImage(String fileName){<br>      this.fileName = fileName;<br>   }</p>
<p>   @Override<br>   public void display() {<br>      if(realImage == null){<br>         realImage = new RealImage(fileName);<br>      }<br>      realImage.display();<br>   }<br>}<br>步骤 3<br>当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<p>ProxyPatternDemo.java<br>public class ProxyPatternDemo {</p>
<p>   public static void main(String[] args) {<br>      Image image = new ProxyImage(“test_10mb.jpg”);</p>
<pre><code>// 图像将从磁盘加载
image.display(); 
System.out.println(&quot;&quot;);
// 图像不需要从磁盘加载
image.display();  
</code></pre><p>   }<br>}<br>步骤 4<br>执行程序，输出结果：</p>
<p>Loading test_10mb.jpg<br>Displaying test_10mb.jpg</p>
<p>Displaying test_10mb.jpg<br> 享元模式</p>
<p>责任链模式 </p>
<p>2 篇笔记 写笔记</p>
<p>   gnehcgnaw</p>
<p>  <a href="mailto:949***604@qq.com" target="_blank" rel="noopener">949***604@qq.com</a></p>
<p>   参考地址</p>
<p>JDK 自带的动态代理</p>
<p> java.lang.reflect.Proxy:生成动态代理类和对象；<br> java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现<br>对真实角色的代理访问。</p>
<p>每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。</p>
<p>代码：</p>
<p>a) 接口：Subject.java</p>
<p>**</p>
<ul>
<li>@author gnehcgnaw</li>
<li><p>@date 2018/11/5 19:29<br>*/<br>public interface Subject {<br> public int sellBooks();</p>
<p> public String speak();<br>}<br>b)真实对象：RealSubject.java</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>@author gnehcgnaw</li>
<li><p>@date 2018/11/5 18:54<br>*/<br>public class RealSubject implements Subject{<br> @Override<br> public int sellBooks() {</p>
<pre><code>System.out.println(&quot;卖书&quot;);
return 1 ;
</code></pre><p> }</p>
<p> @Override<br> public String speak() {</p>
<pre><code>System.out.println(&quot;说话&quot;);
return &quot;张三&quot;;
</code></pre><p> }<br>}<br>c)处理器对象：MyInvocationHandler.java</p>
</li>
</ul>
<p>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;</p>
<p>/**</p>
<ul>
<li>定义一个处理器</li>
<li>@author gnehcgnaw</li>
<li><p>@date 2018/11/5 19:26<br>*/<br>public class MyInvocationHandler implements InvocationHandler {<br> /**</p>
<ul>
<li><p>因为需要处理真实角色，所以要把真实角色传进来<br>*/<br>Subject realSubject ;</p>
<p>public MyInvocationHandler(Subject realSubject) {<br> this.realSubject = realSubject;<br>}</p>
<p>/*<em>
</em></p>
</li>
<li>@param proxy    代理类</li>
<li>@param method    正在调用的方法</li>
<li>@param args      方法的参数</li>
<li>@return</li>
<li>@throws Throwable<br>*/<br>@Override<br>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br> System.out.println(“调用代理类”);<br> if(method.getName().equals(“sellBooks”)){<pre><code>int invoke = (int)method.invoke(realSubject, args);
System.out.println(&quot;调用的是卖书的方法&quot;);
return invoke ;
</code></pre> }else {<pre><code>String string = (String) method.invoke(realSubject,args) ;
System.out.println(&quot;调用的是说话的方法&quot;);
return  string ;
</code></pre> }<br>}<br>}<br>d)调用端：Main.java</li>
</ul>
</li>
</ul>
<p>import java.lang.reflect.Proxy;</p>
<p>/**</p>
<ul>
<li>调用类</li>
<li>@author gnehcgnaw</li>
<li><p>@date 2018/11/7 20:26<br>*/<br>public class Client {<br> public static void main(String[] args) {</p>
<pre><code>//真实对象
Subject realSubject =  new RealSubject();

MyInvocationHandler myInvocationHandler = new MyInvocationHandler(realSubject);
//代理对象
Subject proxyClass = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{Subject.class}, myInvocationHandler);

proxyClass.sellBooks();

proxyClass.speak();
</code></pre><p> }<br>}<br>gnehcgnaw<br>gnehcgnaw</p>
<p><a href="mailto:949***604@qq.com" target="_blank" rel="noopener">949***604@qq.com</a></p>
<p>参考地址</p>
</li>
</ul>
<p>5个月前 (11-13)<br>   逆光影者</p>
<p>  <a href="mailto:248***1388@qq.com" target="_blank" rel="noopener">248***1388@qq.com</a></p>
<p>Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 如果是private或是final类修饰的方法,则不会被重写。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</p>
<p>CGLIB作为一个开源项目，其代码托管在github，地址为：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a></p>
<p>需要代理的类:</p>
<p>package cn.cpf.pattern.structure.proxy.cglib;<br>public class Engineer {<br>    // 可以被代理<br>    public void eat() {<br>        System.out.println(“工程师正在吃饭”);<br>    }</p>
<pre><code>// final 方法不会被生成的字类覆盖
public final void work() {
    System.out.println(&quot;工程师正在工作&quot;);
}

// private 方法不会被生成的字类覆盖
private void play() {
    System.out.println(&quot;this engineer is playing game&quot;);
}
</code></pre><p>}<br>CGLIB 代理类:</p>
<p>package cn.cpf.pattern.structure.proxy.cglib;</p>
<p>import net.sf.cglib.proxy.Enhancer;<br>import net.sf.cglib.proxy.MethodInterceptor;<br>import net.sf.cglib.proxy.MethodProxy;<br>import java.lang.reflect.Method;</p>
<p>public class CglibProxy implements MethodInterceptor {<br>    private Object target;</p>
<pre><code>public CglibProxy(Object target) {
    this.target = target;
}

@Override
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
    System.out.println(&quot;###   before invocation&quot;);
    Object result = method.invoke(target, objects);
    System.out.println(&quot;###   end invocation&quot;);
    return result;
}

public static Object getProxy(Object target) {
    Enhancer enhancer = new Enhancer();
    // 设置需要代理的对象
    enhancer.setSuperclass(target.getClass());
    // 设置代理人
    enhancer.setCallback(new CglibProxy(target));
    return enhancer.create();
}
</code></pre><p>}<br>测试方法:</p>
<p>import java.lang.reflect.Method;<br>import java.util.Arrays;</p>
<p>public class CglibMainTest {<br>    public static void main(String[] args) {<br>        // 生成 Cglib 代理类<br>        Engineer engineerProxy = (Engineer) CglibProxy.getProxy(new Engineer());<br>        // 调用相关方法<br>        engineerProxy.eat();<br>    }<br>}<br>运行结果:</p>
<h3 id="before-invocation"><a href="#before-invocation" class="headerlink" title="before invocation"></a>before invocation</h3><p>工程师正在吃饭</p>
<h3 id="end-invocation"><a href="#end-invocation" class="headerlink" title="end invocation"></a>end invocation</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/单例模式/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:44:28+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/单例模式/" class="leancloud_visitors" data-flag-title="单例模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88933605" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88933605</a></p>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p>
<p>介绍<br>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例：</p>
<p>1、一个班级只有一个班主任。<br>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br>优点：</p>
<p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>2、避免对资源的多重占用（比如写文件操作）。<br>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：</p>
<p>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br>注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<p>实现<br>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。</p>
<p>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。</p>
<p>步骤 1<br>创建一个 Singleton 类。</p>
<p>SingleObject.java<br>public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(“Hello World!”); } }</p>
<p>步骤 2<br>从 singleton 类获取唯一的对象。</p>
<p>SingletonPatternDemo.java<br>public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }</p>
<p>步骤 3<br>执行程序，输出结果：</p>
<p>Hello World!<br>单例模式的几种实现方式<br>单例模式的实现有多种方式，如下所示：</p>
<p>1、懒汉式，线程不安全<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：否</p>
<p>实现难度：易</p>
<p>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p>
<p>实例<br>public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }</p>
<p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p>
<p>2、懒汉式，线程安全<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>实例<br>public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }</p>
<p>3、饿汉式<br>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
<p>实例<br>public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }</p>
<p>4、双检锁/双重校验锁（DCL，即 double-checked locking）<br>JDK 版本：JDK1.5 起</p>
<p>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：较复杂</p>
<p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。</p>
<p>实例<br>public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }</p>
<p>5、登记式/静态内部类<br>是否 Lazy 初始化：是</p>
<p>是否多线程安全：是</p>
<p>实现难度：一般</p>
<p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。</p>
<p>实例<br>public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }</p>
<p>6、枚举<br>JDK 版本：JDK1.5 起</p>
<p>是否 Lazy 初始化：否</p>
<p>是否多线程安全：是</p>
<p>实现难度：易</p>
<p>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<p>实例<br>public enum Singleton { INSTANCE; public void whateverMethod() { } }</p>
<p>经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/抽象工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/抽象工厂模式/" itemprop="url">抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:42:30+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/抽象工厂模式/" class="leancloud_visitors" data-flag-title="抽象工厂模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88933360" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88933360</a></p>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>介绍<br>意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>主要解决：主要解决接口选择的问题。</p>
<p>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p>如何解决：在一个产品族里面，定义多个产品。</p>
<p>关键代码：在一个工厂里聚合多个同类产品。</p>
<p>应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>注意事项：产品族难扩展，产品等级易扩展。</p>
<p>实现<br>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。</p>
<p>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。</p>
<p>步骤 1<br>为形状创建一个接口。</p>
<p>Shape.java<br>public interface Shape { void draw(); }</p>
<p>步骤 2<br>创建实现接口的实体类。</p>
<p>Rectangle.java</p>
<p>Rectangle.java<br>public class Rectangle implements Shape { @Override public void draw() { System.out.println(“Inside Rectangle::draw() method.”); } }</p>
<p>Square.java<br>public class Square implements Shape { @Override public void draw() { System.out.println(“Inside Square::draw() method.”); } }</p>
<p>Circle.java<br>public class Circle implements Shape { @Override public void draw() { System.out.println(“Inside Circle::draw() method.”); } }</p>
<p>步骤 3<br>为颜色创建一个接口。</p>
<p>Color.java<br>public interface Color { void fill(); }</p>
<p>步骤4<br>创建实现接口的实体类。</p>
<p>Red.java<br>public class Red implements Color { @Override public void fill() { System.out.println(“Inside Red::fill() method.”); } }</p>
<p>Green.java<br>public class Green implements Color { @Override public void fill() { System.out.println(“Inside Green::fill() method.”); } }</p>
<p>Blue.java<br>public class Blue implements Color { @Override public void fill() { System.out.println(“Inside Blue::fill() method.”); } }</p>
<p>步骤 5<br>为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<p>AbstractFactory.java<br>public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape) ; }</p>
<p>步骤 6<br>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<p>ShapeFactory.java<br>public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(“CIRCLE”)){ return new Circle(); } else if(shapeType.equalsIgnoreCase(“RECTANGLE”)){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(“SQUARE”)){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } }</p>
<p>ColorFactory.java<br>public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(“RED”)){ return new Red(); } else if(color.equalsIgnoreCase(“GREEN”)){ return new Green(); } else if(color.equalsIgnoreCase(“BLUE”)){ return new Blue(); } return null; } }</p>
<p>步骤 7<br>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p>
<p>FactoryProducer.java<br>public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(“SHAPE”)){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(“COLOR”)){ return new ColorFactory(); } return null; } }</p>
<p>步骤 8<br>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<p>AbstractFactoryPatternDemo.java<br>public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(“SHAPE”); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(“CIRCLE”); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(“RECTANGLE”); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(“SQUARE”); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(“COLOR”); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(“RED”); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(“Green”); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(“BLUE”); //调用 Blue 的 fill 方法 color3.fill(); } }</p>
<p>步骤 9<br>执行程序，输出结果：</p>
<p>Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.<br>Inside Red::fill() method.<br>Inside Green::fill() method.<br>Inside Blue::fill() method.<br> 工厂模式</p>
<p>单例模式 </p>
<p>1 篇笔记 写笔记</p>
<p>   涛</p>
<p>  <a href="mailto:307***9849@qq.com" target="_blank" rel="noopener">307***9849@qq.com</a></p>
<p>   参考地址</p>
<p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p>
<p>简单工厂模式<br>简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。</p>
<p>比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p>
<p>工厂模式<br>工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p>
<p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p>
<p>后续直接调用鼠标工厂.生产鼠标()即可</p>
<p>抽象工厂模式<br>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p>
<p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p>
<p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p>
<p>创建工厂时，由戴尔工厂创建。</p>
<p>后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。</p>
<p>在抽象工厂模式中，假设我们需要增加一个工厂</p>
<p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p>
<p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p>
<p>在抽象工厂模式中，假设我们需要增加一个产品</p>
<p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p>
<p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/工厂方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/工厂方法模式/" itemprop="url">工厂方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:41:15+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/工厂方法模式/" class="leancloud_visitors" data-flag-title="工厂方法模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88929956" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88929956</a><br>一、问题<br>在前一章《设计模式读书笔记—–简单工厂模式》中通过披萨的实例介绍了简单工厂模式。在披萨实例中，如果我想根据地域的不同生产出不同口味的披萨，如纽约口味披萨，芝加哥口味披萨。如果利用简单工厂模式，我们需要两个不同的工厂，NYPizzaFactory、ChicagoPizzaFactory。在该地域中有很多的披萨店，他们并不想依照总店的制作流程来生成披萨，而是希望采用他们自己的制作流程。这个时候如果还使用简单工厂模式，因为简单工厂模式是将披萨的制作流程完全承包了。那么怎么办？</p>
<p>二、解决方案<br>我们可以这样解决：将披萨的制作方法交给各个披萨店完成，但是他们只能提供制作完成的披萨，披萨的订单处理仍然要交给披萨工厂去做。也就是说，我们将createPizza()方法放回到PizzaStore中，其他的部分还是保持不变。</p>
<p>三、基本定义<br>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式让实例化推迟到子类。</p>
<p>四、模式结构<br>工厂方法模式的UML结构图：</p>
<p>Product：抽象产品。所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类既可以引用这个接口。而不是具体类。<br>ConcreteProduct：具体产品。<br>Creator：抽象工厂。它实现了所有操纵产品的方法，但不实现工厂方法。Creator所有的子类都必须要实现factoryMethod()方法。<br>ConcreteCreator：具体工厂。制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。<br>工厂方法模式是简单工厂模式的延伸。在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新的对象时，我们只需要添加一个具体的产品和它的创建工厂即可，不需要对原工厂进行任何修改，这样很好地符合了“开闭原则”。</p>
<p>五、工厂方法模式实现<br>针对上面的解决方案，得到如下UML结构图：</p>
<p>抽象产品类：Pizza.java</p>
<p> 1 public abstract class Pizza {<br> 2     protected String name;        //名称<br> 3     protected String dough;       //面团<br> 4     protected String sause;       //酱料<br> 5     protected List<string> toppings = new ArrayList<string>();       //佐料<br> 6<br> 7<br> 8     public void prepare() {<br> 9         System.out.println(“Preparing “+name);<br>10         System.out.println(“Tossing dough”);<br>11         System.out.println(“Adding sause”);<br>12         System.out.println(“Adding toppings”);<br>13         for(int i = 0;i &lt; toppings.size();i++){<br>14             System.out.println(“   “+toppings.get(i));<br>15         }<br>16     }<br>17<br>18     public void bake() {<br>19         System.out.println(“Bake for 25 minutes at 350”);<br>20     }<br>21<br>22     public void cut() {<br>23         System.out.println(“Cutting the pizza into diagonal slices”);<br>24     }<br>25<br>26     public void box() {<br>27         System.out.println(“Place pizza in official PizzaStore box”);<br>28     }<br>29<br>30     public String getName(){<br>31         return name;<br>32     }<br>33 }<br>具体产品类：NYStyleCheesePizza.java</string></string></p>
<p> 1 public class NYStyleCheesePizza extends Pizza{<br> 2     public NYStyleCheesePizza(){<br> 3         name = “Ny Style Sauce and Cheese Pizza”;<br> 4         dough = “Thin Crust Dough”;<br> 5         sause = “Marinara Sauce”;<br> 6<br> 7         toppings.add(“Crated Reggiano Cheese”);<br> 8     }<br> 9<br>10 }<br>ChicagoStyleCheesePizza.java</p>
<p> 1 public class ChicagoStyleCheesePizza extends Pizza {<br> 2     public ChicagoStyleCheesePizza(){<br> 3         name = “Chicago Style Deep Dish Cheese Pizza”;<br> 4         dough = “Extra Thick Crust Dough”;<br> 5         sause = “Plum Tomato Sauce”;<br> 6<br> 7         toppings.add(“Shredded Mozzarella Cheese”);<br> 8     }<br> 9<br>10     public void cut(){<br>11         System.out.println(“Cutting the Pizza into square slices”);<br>12     }<br>13 }<br>抽象工厂：披萨总店。PizzaStore.java</p>
<p> 1 public abstract class PizzaStore {<br> 2     public Pizza orderPizza(String type){<br> 3         Pizza pizza;<br> 4         pizza = createPizza(type);<br> 5<br> 6         pizza.prepare();<br> 7         pizza.bake();<br> 8         pizza.cut();<br> 9         pizza.box();<br>10<br>11         return pizza;<br>12     }<br>13<br>14     /<em><br>15      </em> 创建pizza的方法交给子类去实现<br>16      */<br>17     abstract Pizza createPizza(String type);<br>18 }<br>具体工厂。披萨分店。NYPizzaStore.java</p>
<p> 1 public class NYPizzaStore extends PizzaStore{<br> 2<br> 3     @Override<br> 4     Pizza createPizza(String item) {<br> 5         Pizza pizza = null;<br> 6         if(“cheese”.equals(item)){<br> 7             pizza = new NYStyleCheesePizza();<br> 8         }<br> 9         else if(“veggie”.equals(item)){<br>10             pizza = new NYStyleVeggiePizza();<br>11         }<br>12         else if(“clam”.equals(item)){<br>13             pizza = new NYStyleClamPizza();<br>14         }<br>15         else if(“pepperoni”.equals(item)){<br>16             pizza = new NYStylePepperoniPizza();<br>17         }<br>18<br>19         return pizza;<br>20     }<br>ChicagoPizzaStore.java</p>
<p> 1 public class ChicagoPizzaStore extends PizzaStore {<br> 2     Pizza createPizza(String type) {<br> 3         Pizza pizza = null;<br> 4         if(“cheese”.equals(type)){<br> 5             pizza = new ChicagoStyleCheesePizza();<br> 6         }<br> 7         else if(“clam”.equals(type)){<br> 8             pizza = new ChicagoStyleClamPizza();<br> 9         }<br>10         else if(“pepperoni”.equals(type)) {<br>11             pizza = new ChicagoStylePepperoniPizza();<br>12         }<br>13         else if(“veggie”.equals(type)){<br>14             pizza = new ChicagoStyleVeggiePizza();<br>15         }<br>16         return pizza;<br>17     }<br>18<br>19 }<br>做了这么多，应该可以吃披萨了吧。Ethan要一份纽约口味的披萨，Joel需要芝加哥口味的披萨。</p>
<p>PizzaTestDrive.java</p>
<p> 1 public class PizzaTestDrive {<br> 2     public static void main(String[] args) {<br> 3         System.out.println(“———Joel 需要的芝加哥的深盘披萨———“);<br> 4         ChicagoPizzaStore chicagoPizzaStore = new ChicagoPizzaStore();       //建立芝加哥的披萨店<br> 5         Pizza joelPizza =chicagoPizzaStore.orderPizza(“cheese”);             //下订单<br> 6         System.out.println(“Joel ordered a “ + joelPizza.getName() + “\n”);<br> 7<br> 8         System.out.println(“———Ethan 需要的纽约风味的披萨———“);<br> 9         NYPizzaStore nyPizzaStore = new NYPizzaStore();<br>10         Pizza ethanPizza = nyPizzaStore.orderPizza(“cheese”);<br>11         System.out.println(“Ethan ordered a “ + ethanPizza.getName() + “\n”);<br>12<br>13     }<br>14 }<br>运行结果。</p>
<p>六、工厂方法模式的优缺点<br>优点<br>1、  在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。<br>2、  在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。<br>缺点<br>1、  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br>七、工厂方法适用场景<br>1、一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。<br>2、一个类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。<br>3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。<br>八、总结<br>1、工厂方法模式完全符合“开闭原则”。<br>2、工厂方法模式使用继承，将对象的创建委托给子类，通过子类实现工厂方法来创建对象。<br>3、工厂方法允许类将实例化延伸到子类进行。<br>4、工厂方法让子类决定要实例化的类时哪一个。在这里我们要明白这并不是工厂来决定生成哪种产品，而是在编写创建者类时，不需要知道实际创建的产品是哪个，选择了使用哪个子类，就已经决定了实际创建的产品时哪个了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/简单工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/简单工厂模式/" itemprop="url">简单工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:40:37+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/简单工厂模式/" class="leancloud_visitors" data-flag-title="简单工厂模式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88858312" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88858312</a></p>
<p>在设计原则中有这样一句话“我们应该针对接口编程，而不是正对实现编程”。但是我们还是在一直使用new关键字来创建一个对象，这不就是在针对实现编程么？</p>
<p>针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。入股代码是针对接口而写，那么可以通过多态，它可以与任何新类实现该接口。但是，当代码使用一大堆的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须要改变代码。在这里我们希望能够调用一个简单的方法，我传递一个参数过去，就可以返回给我一个相应的具体对象，这个时候我们就可以使用简单工厂模式。</p>
<p>一、基本定义<br>简单工厂模式又称之为静态工厂方法，属于创建型模式。在简单工厂模式中，可以根据传递的参数不同，返回不同类的实例。简单工厂模式定义了一个类，这个类专门用于创建其他类的实例，这些被创建的类都有一个共同的父类。</p>
<p>二、模式结构<br>模式结构图如下：</p>
<p>模式分析：</p>
<p>Factory：工厂角色。专门用于创建实例类的工厂，提供一个方法，该方法根据传递的参数不同返回不同类的具体实例。<br>Product：抽象产品角色。为所有产品的父类。<br>ConcreteProduct：具体的产品角色。<br>简单工厂模式将对象的创建和对象本身业务处理分离了，可以降低系统的耦合度，使得两者修改起来都相对容易些。当以后实现改变时，只需要修改工厂类即可。</p>
<p>三、简单工厂模式实现<br>模式场景：在一个披萨店中，要根据不同客户的口味，生产不同的披萨，如素食披萨、希腊披萨等披萨。</p>
<p>该例的UML结构图如下:</p>
<p>代码实现</p>
<p>Pizza制造工厂：SimplyPizzaFactory.java</p>
<p> 1 /*<em><br> 2  </em> 专门用于创建披萨的工厂类<br> 3  */<br> 4 public class SimplePizzaFactory {<br> 5     public Pizza createPizza(String type){<br> 6         Pizza pizza = null;<br> 7<br> 8         if(type.equals(“cheese”)){<br> 9             pizza = new CheesePizza();<br>10         }<br>11         else if(type.equals(“clam”)){<br>12             pizza = new ClamPizza();<br>13         }<br>14         else if(type.equals(“pepperoni”)){<br>15             pizza = new PepperoniPizza();<br>16         }<br>17         else if(type.equals(“veggie”)){<br>18             pizza = new VeggiePizze();<br>19         }<br>20<br>21         return pizza;<br>22     }<br>23 }<br>抽象披萨：Pizza.java</p>
<p> 1 /*<em><br> 2  </em> 抽象pizza类<br> 3  */<br> 4 public abstract class Pizza {<br> 5     public abstract void prepare();<br> 6<br> 7     public abstract void bake();<br> 8<br> 9     public abstract void cut();<br>10<br>11     public abstract void box();<br>12 }<br>具体披萨：CheesePizza.java</p>
<p> 1 public class CheesePizza extends Pizza{<br> 2<br> 3     @Override<br> 4     public void bake() {<br> 5         System.out.println(“bake CheesePizza …”);<br> 6     }<br> 7<br> 8     @Override<br> 9     public void box() {<br>10         System.out.println(“box CheesePizza …”);<br>11     }<br>12<br>13     @Override<br>14     public void cut() {<br>15         System.out.println(“cut CheesePizza …”);<br>16     }<br>17<br>18     @Override<br>19     public void prepare() {<br>20         System.out.println(“prepare CheesePizza …”);<br>21     }<br>22<br>23 }<br>PizzaStore.java</p>
<p> 1 public class PizzaStore {<br> 2     SimplePizzaFactory factory;      //SimplePizzaFactory的引用<br> 3     public PizzaStore(SimplePizzaFactory factory){<br> 4         this.factory = factory;<br> 5     }<br> 6<br> 7     public Pizza orderPizza(String type){<br> 8         Pizza pizza;<br> 9         pizza = factory.createPizza(type);       //使用工厂对象的创建方法，而不是直接new。这里不再使用具体实例化<br>10<br>11         pizza.prepare();<br>12         pizza.bake();<br>13         pizza.cut();<br>14         pizza.box();<br>15<br>16         return pizza;<br>17     }<br>18 }<br>四、简单工厂模式的优缺点<br>优点<br>1、简单工厂模式实现了对责任的分割，提供了专门的工厂类用于创建对象。<br>2、客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。<br>3、通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。<br>缺点<br>1、由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。<br>2、使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。<br>3、系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。<br>4、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。<br>五、简单工厂模式的使用场景<br>1、  工厂类负责创建的对象比较少。<br>2、  客户端只知道传入工厂类的参数，对于如何创建对象不关心。<br>六、总结<br>1、  简单工厂模式的要点就在于当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/Spring-Bean-生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HybridTheory">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HybridTheory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/Spring-Bean-生命周期/" itemprop="url">Spring Bean 生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T17:39:14+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/28/Spring-Bean-生命周期/" class="leancloud_visitors" data-flag-title="Spring Bean 生命周期">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  912
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/HybridTheory_/article/details/88829053" target="_blank" rel="noopener">https://blog.csdn.net/HybridTheory_/article/details/88829053</a><br>前言<br>Spring Bean 的生命周期在整个 Spring 中占有很重要的位置，掌握这些可以加深对 Spring 的理解。</p>
<p>首先看下生命周期图：</p>
<p>再谈生命周期之前有一点需要先明确：</p>
<p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype （原型模式：多例） 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
<p>注解方式<br>在 bean 初始化时会经历几个阶段，首先可以使用注解 @PostConstruct, @PreDestroy 来在 bean 的创建和销毁阶段进行调用:</p>
<p>@Component<br>public class AnnotationBean {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(AnnotationBean.class);</p>
<pre><code>@PostConstruct
public void start(){
    LOGGER.info(&quot;AnnotationBean start&quot;);
}

@PreDestroy
public void destroy(){
    LOGGER.info(&quot;AnnotationBean destroy&quot;);
}
</code></pre><p>}<br>InitializingBean, DisposableBean 接口<br>还可以实现 InitializingBean,DisposableBean 这两个接口，也是在初始化以及销毁阶段调用：</p>
<p>@Service<br>public class SpringLifeCycleService implements InitializingBean,DisposableBean{<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleService.class);<br>    @Override<br>    public void afterPropertiesSet() throws Exception {<br>        LOGGER.info(“SpringLifeCycleService start”);<br>    }</p>
<pre><code>@Override
public void destroy() throws Exception {
    LOGGER.info(&quot;SpringLifeCycleService destroy&quot;);
}
</code></pre><p>}<br>自定义初始化和销毁方法<br>也可以自定义方法用于在初始化、销毁阶段调用:</p>
<p>@Configuration<br>public class LifeCycleConfig {</p>
<pre><code>@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)
public SpringLifeCycle create(){
    SpringLifeCycle springLifeCycle = new SpringLifeCycle() ;

    return springLifeCycle ;
}
</code></pre><p>}</p>
<p>public class SpringLifeCycle{</p>
<pre><code>private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycle.class);
public void start(){
    LOGGER.info(&quot;SpringLifeCycle start&quot;);
}


public void destroy(){
    LOGGER.info(&quot;SpringLifeCycle destroy&quot;);
}
</code></pre><p>}<br>以上是在 SpringBoot 中可以这样配置，如果是原始的基于 XML 也是可以使用:</p>
<p><bean class="com.crossoverjie.spring.SpringLifeCycle" init-method="start" destroy-method="destroy"><br></bean><br>来达到同样的效果。</p>
<p>实现 <em>Aware 接口
</em>Aware 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 Spring 上下文等。</p>
<p>@Component<br>public class SpringLifeCycleAware implements ApplicationContextAware {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleAware.class);</p>
<pre><code>private ApplicationContext applicationContext ;

@Override
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
    this.applicationContext = applicationContext ;
    LOGGER.info(&quot;SpringLifeCycleAware start&quot;);
}
</code></pre><p>}<br>这样在 springLifeCycleAware 这个 bean 初始化会就会调用 setApplicationContext 方法，并可以获得 applicationContext 对象。</p>
<p>BeanPostProcessor 增强处理器<br>实现 BeanPostProcessor 接口，Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，可以用于对一些特殊的 bean 进行处理：</p>
<p>@Component<br>public class SpringLifeCycleProcessor implements BeanPostProcessor {<br>    private final static Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleProcessor.class);</p>
<pre><code>/**
 * 预初始化 初始化之前调用
 * @param bean
 * @param beanName
 * @return
 * @throws BeansException
 */
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (&quot;annotationBean&quot;.equals(beanName)){
        LOGGER.info(&quot;SpringLifeCycleProcessor start beanName={}&quot;,beanName);
    }
    return bean;
}

/**
 * 后初始化  bean 初始化完成调用
 * @param bean
 * @param beanName
 * @return
 * @throws BeansException
 */
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (&quot;annotationBean&quot;.equals(beanName)){
        LOGGER.info(&quot;SpringLifeCycleProcessor end beanName={}&quot;,beanName);
    }
    return bean;
}
</code></pre><p>}<br>执行之后观察结果：</p>
<p>018-03-21 00:40:24.856 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor start beanName=annotationBean<br>2018-03-21 00:40:24.860 [restartedMain] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean start<br>2018-03-21 00:40:24.861 [restartedMain] INFO  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor end beanName=annotationBean<br>2018-03-21 00:40:24.864 [restartedMain] INFO  c.c.s.aware.SpringLifeCycleAware - SpringLifeCycleAware start<br>2018-03-21 00:40:24.867 [restartedMain] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService start<br>2018-03-21 00:40:24.887 [restartedMain] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle start<br>2018-03-21 00:40:25.062 [restartedMain] INFO  o.s.b.d.a.OptionalLiveReloadServer - LiveReload server is running on port 35729<br>2018-03-21 00:40:25.122 [restartedMain] INFO  o.s.j.e.a.AnnotationMBeanExporter - Registering beans for JMX exposure on startup<br>2018-03-21 00:40:25.140 [restartedMain] INFO  com.crossoverjie.Application - Started Application in 2.309 seconds (JVM running for 3.681)<br>2018-03-21 00:40:25.143 [restartedMain] INFO  com.crossoverjie.Application - start ok!<br>2018-03-21 00:40:25.153 [Thread-8] INFO  o.s.c.a.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3913adad: startup date [Wed Mar 21 00:40:23 CST 2018]; root of context hierarchy<br>2018-03-21 00:40:25.155 [Thread-8] INFO  o.s.j.e.a.AnnotationMBeanExporter - Unregistering JMX-exposed beans on shutdown<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.SpringLifeCycle - SpringLifeCycle destroy<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService destroy<br>2018-03-21 00:40:25.156 [Thread-8] INFO  c.c.spring.annotation.AnnotationBean - AnnotationBean destroy</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="HybridTheory">
            
              <p class="site-author-name" itemprop="name">HybridTheory</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry ,Stay foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="200" height="86" src="//music.163.com/outchain/player?type=2&id=1329464393&auto=0&height=66"></iframe>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/yourname" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yourname" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://vk.com/yourname" target="_blank" title="VK Group">
                      
                        <i class="fa fa-fw fa-vk"></i>VK Group</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/yourname" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/yourname" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/yourname" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="skype:yourname?call|chat" target="_blank" title="Skype">
                      
                        <i class="fa fa-fw fa-skype"></i>Skype</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HybridTheory</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">43.9k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("Sv4QpdTAhVRkfNsWlhNnvGfo-gzGzoHsz", "4g1FnHoULfh2ekJwdKDWsfhY");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
